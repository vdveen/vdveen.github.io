<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geochron - Live Earth Visualization</title>

    <!-- Leaflet CSS -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />

    <style>
        /* ==========================================================================
           CSS Variables & Base Styles
           ========================================================================== */
        :root {
            --bg-primary: #1a1a2e;
            --bg-secondary: #16213e;
            --bg-tertiary: #0f3460;
            --text-primary: #eaeaea;
            --text-secondary: #a0a0a0;
            --accent: #e94560;
            --accent-hover: #ff6b6b;
            --success: #4ecca3;
            --warning: #ffc107;
            --border: #2a2a4a;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            overflow: hidden;
            height: 100vh;
            width: 100vw;
        }

        /* ==========================================================================
           Layout
           ========================================================================== */
        .app-container {
            display: flex;
            flex-direction: column;
            height: 100vh;
            width: 100vw;
        }

        /* Timezone Bar (Top) */
        .timezone-bar {
            height: 36px;
            background: var(--bg-secondary);
            border-bottom: 1px solid var(--border);
            display: flex;
            align-items: stretch;
            justify-content: stretch;
            font-size: 11px;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            flex-shrink: 0;
        }

        .timezone-bar .tz-label {
            flex: 1 1 0;
            min-width: 0;
            text-align: center;
            padding: 4px 6px;
            border-right: 1px solid var(--border);
            white-space: nowrap;
            overflow: hidden;
            display: flex;
            flex-direction: column;
            justify-content: center;
        }

        .timezone-bar .tz-label:last-child {
            border-right: none;
        }

        .timezone-bar .tz-label .tz-letter {
            font-size: 12px;
            font-weight: bold;
            color: var(--text-primary);
        }

        .timezone-bar .tz-label .tz-offset-text {
            font-size: 9px;
            color: var(--text-secondary);
        }

        .timezone-bar .tz-label .tz-time {
            font-size: 10px;
            color: var(--accent);
            font-weight: 500;
        }

        .timezone-bar .tz-label.fractional {
            background: rgba(255, 193, 7, 0.1);
        }

        .timezone-bar .tz-label.fractional .tz-offset-text {
            color: #ffc107;
        }

        /* Map Container */
        #map {
            flex: 1;
            width: 100%;
            background: var(--bg-primary);
        }

        /* ==========================================================================
           Control Panel
           ========================================================================== */
        .control-panel {
            position: absolute;
            top: 44px;
            right: 10px;
            z-index: 1000;
            background: var(--bg-secondary);
            border-radius: 8px;
            box-shadow: 0 4px 12px var(--shadow);
            border: 1px solid var(--border);
            min-width: 220px;
            max-height: calc(100vh - 100px);
            overflow-y: auto;
        }

        .control-panel-header {
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border-radius: 8px 8px 0 0;
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
            user-select: none;
        }

        .control-panel-header h3 {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .control-panel-toggle {
            background: none;
            border: none;
            color: var(--text-primary);
            cursor: pointer;
            font-size: 16px;
            padding: 4px;
        }

        .control-panel-content {
            padding: 8px 0;
        }

        .control-panel.collapsed .control-panel-content {
            display: none;
        }

        /* Layer Groups */
        .layer-group {
            padding: 8px 16px;
            border-bottom: 1px solid var(--border);
        }

        .layer-group:last-child {
            border-bottom: none;
        }

        .layer-group-title {
            font-size: 11px;
            text-transform: uppercase;
            color: var(--text-secondary);
            margin-bottom: 8px;
            font-weight: 600;
            letter-spacing: 0.5px;
        }

        /* Layer Toggle */
        .layer-toggle {
            display: flex;
            align-items: center;
            padding: 6px 0;
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .layer-toggle:hover {
            opacity: 0.8;
        }

        .layer-toggle.disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .layer-toggle input[type="checkbox"] {
            display: none;
        }

        .layer-toggle .toggle-switch {
            width: 36px;
            height: 20px;
            background: var(--border);
            border-radius: 10px;
            position: relative;
            margin-right: 10px;
            transition: background 0.2s;
            flex-shrink: 0;
        }

        .layer-toggle .toggle-switch::after {
            content: '';
            position: absolute;
            width: 16px;
            height: 16px;
            background: var(--text-secondary);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s, background 0.2s;
        }

        .layer-toggle input:checked + .toggle-switch {
            background: var(--accent);
        }

        .layer-toggle input:checked + .toggle-switch::after {
            transform: translateX(16px);
            background: white;
        }

        .layer-toggle .toggle-label {
            font-size: 13px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .layer-toggle .toggle-icon {
            font-size: 16px;
        }

        .layer-toggle .api-required {
            font-size: 9px;
            background: var(--warning);
            color: #000;
            padding: 2px 4px;
            border-radius: 3px;
            margin-left: 4px;
        }

        /* Settings Button */
        .settings-btn {
            width: 100%;
            padding: 12px 16px;
            background: var(--bg-tertiary);
            border: none;
            color: var(--text-primary);
            font-size: 13px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            transition: background 0.2s;
        }

        .settings-btn:hover {
            background: var(--accent);
        }

        /* ==========================================================================
           Status Bar
           ========================================================================== */
        .status-bar {
            height: 28px;
            background: var(--bg-secondary);
            border-top: 1px solid var(--border);
            display: flex;
            align-items: center;
            padding: 0 16px;
            font-size: 11px;
            color: var(--text-secondary);
            gap: 20px;
            flex-shrink: 0;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .status-item .status-icon {
            font-size: 12px;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--success);
        }

        .status-dot.loading {
            background: var(--warning);
            animation: pulse 1s infinite;
        }

        .status-dot.error {
            background: var(--accent);
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* ==========================================================================
           Modal
           ========================================================================== */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 2000;
            opacity: 0;
            visibility: hidden;
            transition: opacity 0.2s, visibility 0.2s;
        }

        .modal-overlay.active {
            opacity: 1;
            visibility: visible;
        }

        .modal {
            background: var(--bg-secondary);
            border-radius: 12px;
            width: 90%;
            max-width: 500px;
            max-height: 80vh;
            overflow: hidden;
            box-shadow: 0 8px 32px var(--shadow);
            border: 1px solid var(--border);
        }

        .modal-header {
            padding: 16px 20px;
            background: var(--bg-tertiary);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .modal-header h2 {
            font-size: 18px;
            font-weight: 600;
        }

        .modal-close {
            background: none;
            border: none;
            color: var(--text-primary);
            font-size: 24px;
            cursor: pointer;
            padding: 4px;
            line-height: 1;
        }

        .modal-close:hover {
            color: var(--accent);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            max-height: calc(80vh - 60px);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            font-weight: 500;
            margin-bottom: 6px;
        }

        .form-group .form-hint {
            font-size: 11px;
            color: var(--text-secondary);
            margin-top: 4px;
        }

        .form-group .form-hint a {
            color: var(--accent);
            text-decoration: none;
        }

        .form-group .form-hint a:hover {
            text-decoration: underline;
        }

        .form-group input[type="text"],
        .form-group input[type="password"] {
            width: 100%;
            padding: 10px 12px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-size: 14px;
        }

        .form-group input:focus {
            outline: none;
            border-color: var(--accent);
        }

        .form-actions {
            display: flex;
            gap: 12px;
            justify-content: flex-end;
            padding-top: 12px;
            border-top: 1px solid var(--border);
        }

        .btn {
            padding: 10px 20px;
            border-radius: 6px;
            font-size: 14px;
            font-weight: 500;
            cursor: pointer;
            transition: background 0.2s;
            border: none;
        }

        .btn-primary {
            background: var(--accent);
            color: white;
        }

        .btn-primary:hover {
            background: var(--accent-hover);
        }

        .btn-secondary {
            background: var(--border);
            color: var(--text-primary);
        }

        .btn-secondary:hover {
            background: var(--bg-tertiary);
        }

        /* ==========================================================================
           Map Custom Styles
           ========================================================================== */
        .leaflet-container {
            background: var(--bg-primary);
        }

        /* Sun marker */
        .sun-marker {
            font-size: 24px;
            text-shadow: 0 0 20px #ffeb3b, 0 0 40px #ff9800;
        }

        /* Analemma tooltip */
        .analemma-tooltip {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            color: var(--text-primary);
            font-size: 11px;
            padding: 2px 6px;
            border-radius: 4px;
        }

        /* ISS marker */
        .iss-marker {
            font-size: 20px;
            filter: drop-shadow(0 0 4px rgba(255, 255, 255, 0.8));
        }

        /* Satellite markers */
        .satellite-marker {
            font-size: 14px;
            color: #4fc3f7;
            text-shadow: 0 0 4px #4fc3f7;
        }

        /* User satellite markers (larger, with custom colors) */
        .user-satellite-marker {
            font-size: 18px;
            filter: drop-shadow(0 0 6px currentColor);
        }

        .user-satellite-label {
            background: rgba(22, 33, 62, 0.9);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            color: var(--text-primary);
            white-space: nowrap;
            pointer-events: none;
        }

        /* User Satellites Layer Panel */
        .user-sat-list {
            max-height: 200px;
            overflow-y: auto;
            margin-top: 8px;
        }

        .user-sat-item {
            display: flex;
            align-items: center;
            padding: 6px 0;
            gap: 8px;
            border-bottom: 1px solid var(--border);
        }

        .user-sat-item:last-child {
            border-bottom: none;
        }

        .user-sat-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            flex-shrink: 0;
            cursor: pointer;
            border: 1px solid rgba(255,255,255,0.3);
        }

        .user-sat-info {
            flex: 1;
            min-width: 0;
        }

        .user-sat-name {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .user-sat-meta {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .user-sat-meta.stale {
            color: var(--warning);
        }

        .user-sat-meta.very-stale {
            color: var(--accent);
        }

        .user-sat-toggle {
            width: 28px;
            height: 16px;
            background: var(--border);
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            flex-shrink: 0;
        }

        .user-sat-toggle::after {
            content: '';
            position: absolute;
            width: 12px;
            height: 12px;
            background: var(--text-secondary);
            border-radius: 50%;
            top: 2px;
            left: 2px;
            transition: transform 0.2s, background 0.2s;
        }

        .user-sat-toggle.active {
            background: var(--accent);
        }

        .user-sat-toggle.active::after {
            transform: translateX(12px);
            background: white;
        }

        .user-sat-actions {
            display: flex;
            gap: 4px;
            flex-shrink: 0;
        }

        .user-sat-btn {
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            padding: 2px 4px;
            font-size: 12px;
            border-radius: 3px;
        }

        .user-sat-btn:hover {
            background: var(--border);
            color: var(--text-primary);
        }

        .user-sat-btn.delete:hover {
            color: var(--accent);
        }

        .add-sat-btn {
            width: 100%;
            padding: 8px;
            margin-top: 8px;
            background: var(--bg-tertiary);
            border: 1px dashed var(--border);
            border-radius: 6px;
            color: var(--text-secondary);
            font-size: 12px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
            transition: all 0.2s;
        }

        .add-sat-btn:hover {
            border-color: var(--accent);
            color: var(--text-primary);
            background: rgba(233, 69, 96, 0.1);
        }

        .user-sat-empty {
            text-align: center;
            padding: 16px 8px;
            color: var(--text-secondary);
            font-size: 11px;
        }

        /* TLE Import Modal */
        .import-tabs {
            display: flex;
            border-bottom: 1px solid var(--border);
            margin-bottom: 16px;
        }

        .import-tab {
            flex: 1;
            padding: 10px;
            background: none;
            border: none;
            color: var(--text-secondary);
            cursor: pointer;
            font-size: 13px;
            border-bottom: 2px solid transparent;
            transition: all 0.2s;
        }

        .import-tab:hover {
            color: var(--text-primary);
        }

        .import-tab.active {
            color: var(--accent);
            border-bottom-color: var(--accent);
        }

        .import-panel {
            display: none;
        }

        .import-panel.active {
            display: block;
        }

        .tle-textarea {
            width: 100%;
            height: 120px;
            background: var(--bg-primary);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'Courier New', monospace;
            font-size: 11px;
            padding: 10px;
            resize: vertical;
        }

        .tle-textarea:focus {
            outline: none;
            border-color: var(--accent);
        }

        .file-drop-zone {
            border: 2px dashed var(--border);
            border-radius: 8px;
            padding: 32px 16px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
        }

        .file-drop-zone:hover,
        .file-drop-zone.dragover {
            border-color: var(--accent);
            background: rgba(233, 69, 96, 0.1);
        }

        .file-drop-zone .drop-icon {
            font-size: 32px;
            margin-bottom: 8px;
        }

        .file-drop-zone .drop-text {
            color: var(--text-secondary);
            font-size: 13px;
        }

        .file-drop-zone .drop-hint {
            color: var(--text-secondary);
            font-size: 11px;
            margin-top: 4px;
        }

        .file-input-hidden {
            display: none;
        }

        /* Preview list */
        .import-preview {
            margin-top: 16px;
            border-top: 1px solid var(--border);
            padding-top: 12px;
        }

        .preview-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .preview-title {
            font-size: 12px;
            font-weight: 500;
        }

        .preview-count {
            font-size: 11px;
            color: var(--text-secondary);
        }

        .preview-list {
            max-height: 180px;
            overflow-y: auto;
        }

        .preview-item {
            display: flex;
            align-items: center;
            padding: 8px;
            background: var(--bg-primary);
            border-radius: 6px;
            margin-bottom: 6px;
            gap: 10px;
        }

        .preview-item:last-child {
            margin-bottom: 0;
        }

        .preview-checkbox {
            flex-shrink: 0;
        }

        .preview-info {
            flex: 1;
            min-width: 0;
        }

        .preview-name {
            font-size: 12px;
            font-weight: 500;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .preview-meta {
            font-size: 10px;
            color: var(--text-secondary);
        }

        .preview-color-picker {
            width: 24px;
            height: 24px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            padding: 0;
            background: none;
        }

        .preview-warning {
            display: flex;
            align-items: center;
            gap: 6px;
            padding: 8px;
            background: rgba(255, 193, 7, 0.1);
            border: 1px solid rgba(255, 193, 7, 0.3);
            border-radius: 6px;
            margin-bottom: 8px;
            font-size: 11px;
            color: var(--warning);
        }

        .preview-error {
            background: rgba(233, 69, 96, 0.1);
            border-color: rgba(233, 69, 96, 0.3);
            color: var(--accent);
        }

        /* Aircraft markers */
        .aircraft-marker {
            font-size: 14px;
            color: #ffeb3b;
            transition: transform 0.5s ease;
        }

        /* Timezone polygons */
        .timezone-polygon {
            stroke: rgba(128, 128, 128, 0.4);
            stroke-width: 1;
            fill: transparent;
            fill-opacity: 0;
        }

        .timezone-polygon:hover {
            stroke: rgba(128, 128, 128, 0.8);
            stroke-width: 2;
        }

        /* Timezone offset labels on map */
        .timezone-offset-label {
            background: rgba(22, 33, 62, 0.85);
            border: 1px solid rgba(128, 128, 128, 0.5);
            border-radius: 4px;
            padding: 2px 6px;
            font-size: 10px;
            font-family: 'Courier New', monospace;
            color: var(--text-secondary);
            white-space: nowrap;
            pointer-events: none;
        }

        .timezone-offset-label.fractional {
            color: #ffc107;
            border-color: rgba(255, 193, 7, 0.5);
        }

        /* Timezone hover tooltip */
        .timezone-tooltip {
            position: absolute;
            background: var(--bg-secondary);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px 12px;
            font-size: 12px;
            z-index: 1500;
            pointer-events: none;
            box-shadow: 0 4px 12px var(--shadow);
        }

        .timezone-tooltip .tz-name {
            font-weight: 600;
            margin-bottom: 4px;
        }

        .timezone-tooltip .tz-offset {
            color: var(--text-secondary);
            font-family: 'Courier New', monospace;
        }

        /* Custom popup */
        .leaflet-popup-content-wrapper {
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 8px;
            border: 1px solid var(--border);
        }

        .leaflet-popup-tip {
            background: var(--bg-secondary);
            border: 1px solid var(--border);
        }

        .leaflet-popup-content {
            margin: 12px;
            font-size: 13px;
        }

        .popup-title {
            font-weight: 600;
            margin-bottom: 8px;
            font-size: 14px;
        }

        .popup-row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid var(--border);
        }

        .popup-row:last-child {
            border-bottom: none;
        }

        .popup-label {
            color: var(--text-secondary);
        }

        /* Loading overlay */
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(26, 26, 46, 0.9);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 3000;
            transition: opacity 0.5s;
        }

        .loading-overlay.hidden {
            opacity: 0;
            pointer-events: none;
        }

        .loading-spinner {
            width: 50px;
            height: 50px;
            border: 3px solid var(--border);
            border-top-color: var(--accent);
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        .loading-text {
            margin-top: 16px;
            font-size: 14px;
            color: var(--text-secondary);
        }

        /* ==========================================================================
           Responsive
           ========================================================================== */
        @media (max-width: 768px) {
            .timezone-bar {
                font-size: 9px;
                height: 32px;
            }

            .timezone-bar .tz-label {
                min-width: 32px;
                padding: 2px 4px;
            }

            .timezone-bar .tz-label .tz-time {
                display: none;
            }

            .timezone-bar .tz-label .tz-offset-text {
                font-size: 8px;
            }

            .control-panel {
                right: 5px;
                min-width: 200px;
            }

            .status-bar {
                font-size: 10px;
                padding: 0 8px;
                gap: 12px;
            }

            .timezone-offset-label {
                font-size: 8px;
            }
        }

        @media (max-width: 480px) {
            .timezone-bar .tz-label {
                padding: 2px;
                min-width: 28px;
            }

            .timezone-bar .tz-label .tz-letter {
                font-size: 10px;
            }

            .timezone-bar .tz-label .tz-offset-text {
                display: none;
            }

            .control-panel {
                min-width: 180px;
            }
        }
    </style>
</head>
<body>
    <!-- Loading Overlay -->
    <div class="loading-overlay" id="loadingOverlay">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading Geochron...</div>
    </div>

    <div class="app-container">
        <!-- Timezone Bar -->
        <div class="timezone-bar" id="timezoneBar">
            <!-- Populated by JavaScript -->
        </div>

        <!-- Map -->
        <div id="map"></div>

        <!-- Control Panel -->
        <div class="control-panel" id="controlPanel">
            <div class="control-panel-header" onclick="toggleControlPanel()">
                <h3><span>üåç</span> Layers</h3>
                <button class="control-panel-toggle" id="panelToggle">‚àí</button>
            </div>
            <div class="control-panel-content">
                <!-- Core Layers -->
                <div class="layer-group">
                    <div class="layer-group-title">Core</div>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-terminator" checked>
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üåì</span> Day/Night
                        </span>
                    </label>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-sun" checked>
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">‚òÄÔ∏è</span> Sun Position
                        </span>
                    </label>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-analemma">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">‚àû</span> Analemma
                        </span>
                    </label>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-timezones" checked>
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üïê</span> Timezones
                        </span>
                    </label>
                </div>

                <!-- Space -->
                <div class="layer-group">
                    <div class="layer-group-title">Space</div>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-iss">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üõ∏</span> ISS
                        </span>
                    </label>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-satellites">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üì°</span> Satellites
                        </span>
                    </label>
                </div>

                <!-- User Satellites -->
                <div class="layer-group">
                    <div class="layer-group-title">My Satellites</div>
                    <div id="userSatList" class="user-sat-list">
                        <div class="user-sat-empty">
                            No satellites added yet.<br>
                            Import a TLE to track custom satellites.
                        </div>
                    </div>
                    <button class="add-sat-btn" onclick="openTLEImport()">
                        <span>+</span> Add Satellite
                    </button>
                    <button class="add-sat-btn" id="clearAllSatsBtn" style="display: none; border-color: var(--accent); color: var(--accent);" onclick="clearAllUserSatellites()">
                        <span>üóëÔ∏è</span> Clear All
                    </button>
                </div>

                <!-- Weather -->
                <div class="layer-group">
                    <div class="layer-group-title">Weather</div>
                    <label class="layer-toggle" id="toggle-radar">
                        <input type="checkbox" id="layer-radar">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üì°</span> Radar (free)
                        </span>
                    </label>
                    <label class="layer-toggle" id="toggle-clouds">
                        <input type="checkbox" id="layer-clouds">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">‚òÅÔ∏è</span> Clouds
                            <span class="api-required">API</span>
                        </span>
                    </label>
                    <label class="layer-toggle" id="toggle-precipitation">
                        <input type="checkbox" id="layer-precipitation">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üåßÔ∏è</span> Precipitation
                            <span class="api-required">API</span>
                        </span>
                    </label>
                    <label class="layer-toggle" id="toggle-temp">
                        <input type="checkbox" id="layer-temp">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üå°Ô∏è</span> Temperature
                            <span class="api-required">API</span>
                        </span>
                    </label>
                    <label class="layer-toggle" id="toggle-wind">
                        <input type="checkbox" id="layer-wind">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üí®</span> Wind
                            <span class="api-required">API</span>
                        </span>
                    </label>
                    <label class="layer-toggle" id="toggle-pressure">
                        <input type="checkbox" id="layer-pressure">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">üìä</span> Pressure
                            <span class="api-required">API</span>
                        </span>
                    </label>
                </div>

                <!-- Aviation -->
                <div class="layer-group">
                    <div class="layer-group-title">Aviation</div>
                    <label class="layer-toggle">
                        <input type="checkbox" id="layer-aircraft">
                        <span class="toggle-switch"></span>
                        <span class="toggle-label">
                            <span class="toggle-icon">‚úàÔ∏è</span> Aircraft
                        </span>
                    </label>
                </div>

                <!-- Settings Button -->
                <button class="settings-btn" onclick="openSettings()">
                    <span>‚öôÔ∏è</span> Settings & API Keys
                </button>
            </div>
        </div>

        <!-- Status Bar -->
        <div class="status-bar">
            <div class="status-item">
                <span class="status-dot" id="statusDot"></span>
                <span id="statusText">Ready</span>
            </div>
            <div class="status-item">
                <span class="status-icon">üåç</span>
                <span id="sunInfo">Loading...</span>
            </div>
            <div class="status-item" id="issStatus" style="display: none;">
                <span class="status-icon">üõ∏</span>
                <span id="issInfo">--</span>
            </div>
            <div class="status-item" id="aircraftStatus" style="display: none;">
                <span class="status-icon">‚úàÔ∏è</span>
                <span id="aircraftInfo">--</span>
            </div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div class="modal-overlay" id="settingsModal">
        <div class="modal">
            <div class="modal-header">
                <h2>‚öôÔ∏è Settings</h2>
                <button class="modal-close" onclick="closeSettings()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="form-group">
                    <label for="apiKeyOpenWeather">OpenWeatherMap API Key</label>
                    <input type="password" id="apiKeyOpenWeather" placeholder="Enter your API key">
                    <p class="form-hint">
                        Required for clouds, temp, wind, pressure layers.
                        Note: Weather Maps 2.0 may require a paid subscription.
                        <a href="https://openweathermap.org/price" target="_blank">Check pricing</a>.
                        Use "Radar (free)" for precipitation without an API key.
                    </p>
                </div>
                <div class="form-group">
                    <label for="proxyUrl">CORS Proxy URL</label>
                    <input type="text" id="proxyUrl" placeholder="https://opensky.asvdveen.workers.dev/">
                    <p class="form-hint">
                        Required for aircraft tracking. Default proxy is pre-configured.
                    </p>
                </div>
                <div class="form-group">
                    <label for="openskyUsername">OpenSky API Client ID</label>
                    <input type="text" id="openskyUsername" placeholder="Enter your API client ID">
                    <p class="form-hint">
                        Optional but recommended for higher rate limits.
                        <a href="https://opensky-network.org/account" target="_blank">Create API client</a>
                    </p>
                </div>
                <div class="form-group">
                    <label for="openskyPassword">OpenSky API Client Secret</label>
                    <input type="password" id="openskyPassword" placeholder="Enter your API client secret">
                    <p class="form-hint">
                        Stored locally in your browser only. Used for OAuth2 authentication.
                    </p>
                </div>
                <div class="form-group">
                    <label for="refreshInterval">Refresh Interval (seconds)</label>
                    <input type="text" id="refreshInterval" placeholder="60">
                    <p class="form-hint">
                        How often to update live data (ISS, aircraft). Default: 60s
                    </p>
                </div>
                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeSettings()">Cancel</button>
                    <button class="btn btn-primary" onclick="saveSettings()">Save</button>
                </div>
            </div>
        </div>
    </div>

    <!-- TLE Import Modal -->
    <div class="modal-overlay" id="tleImportModal">
        <div class="modal">
            <div class="modal-header">
                <h2>üõ∞Ô∏è Add Satellite</h2>
                <button class="modal-close" onclick="closeTLEImport()">&times;</button>
            </div>
            <div class="modal-body">
                <div class="import-tabs">
                    <button class="import-tab active" data-tab="paste" onclick="switchImportTab('paste')">
                        üìã Paste TLE
                    </button>
                    <button class="import-tab" data-tab="file" onclick="switchImportTab('file')">
                        üìÅ Upload File
                    </button>
                </div>

                <!-- Paste Panel -->
                <div id="importPanelPaste" class="import-panel active">
                    <textarea id="tleTextarea" class="tle-textarea" placeholder="Paste TLE data here...

Example (3-line format):
ISS (ZARYA)
1 25544U 98067A   24020.54166667  .00016717  00000-0  10270-3 0  9025
2 25544  51.6403 247.4711 0007185 329.9682  30.0970 15.49952157395432"></textarea>
                    <p class="form-hint" style="margin-top: 8px;">
                        Supports 2-line and 3-line TLE formats. Multiple satellites can be pasted at once.
                    </p>
                </div>

                <!-- File Panel -->
                <div id="importPanelFile" class="import-panel">
                    <div class="file-drop-zone" id="fileDropZone" onclick="document.getElementById('tleFileInput').click()">
                        <div class="drop-icon">üìÇ</div>
                        <div class="drop-text">Drop TLE file here or click to browse</div>
                        <div class="drop-hint">.tle, .txt files supported</div>
                    </div>
                    <input type="file" id="tleFileInput" class="file-input-hidden" accept=".tle,.txt,.TLE,.TXT" onchange="handleFileSelect(event)">
                </div>

                <!-- Preview -->
                <div id="importPreview" class="import-preview" style="display: none;">
                    <div class="preview-header">
                        <span class="preview-title">Preview</span>
                        <span class="preview-count" id="previewCount">0 satellites found</span>
                    </div>
                    <div id="previewMessages"></div>
                    <div id="previewList" class="preview-list"></div>
                </div>

                <div class="form-actions">
                    <button class="btn btn-secondary" onclick="closeTLEImport()">Cancel</button>
                    <button class="btn btn-primary" id="importBtn" onclick="importSelectedSatellites()" disabled>Import Selected</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Leaflet JS -->
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- Leaflet.Terminator - https://github.com/joergdietrich/Leaflet.Terminator -->
    <script src="https://unpkg.com/@joergdietrich/leaflet.terminator"></script>
    <!-- satellite.js for satellite position calculations -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/5.0.0/satellite.min.js"></script>
    <!-- TopoJSON client for timezone boundary data -->
    <script src="https://unpkg.com/topojson-client@3"></script>

    <script>
        /* ==========================================================================
           Configuration
           ========================================================================== */
        const CONFIG = {
            // Default CORS proxy for aircraft data
            defaultProxy: 'https://opensky.asvdveen.workers.dev/',

            // API endpoints
            apis: {
                iss: 'http://api.open-notify.org/iss-now.json',
                issAlt: 'https://api.wheretheiss.at/v1/satellites/25544',
                opensky: 'https://opensky-network.org/api/states/all',
                celestrak: 'https://celestrak.org/NORAD/elements/gp.php',
                openweather: 'https://tile.openweathermap.org/map',
                rainviewer: 'https://tilecache.rainviewer.com/v2/radar',
                // Simplified timezone boundaries (Natural Earth 10m via TopoJSON)
                timezones: 'https://gist.githubusercontent.com/tschaub/cc70281ce4df5358eac38b34409b9ef9/raw/d152ba9e83d7733d9fb5f37f52202c0fcead834a/timezones.json'
            },

            // UTC offset to letter mapping (A-Y for -12 to +12)
            // Integer offsets only; fractional zones display their offset instead
            timezoneLetters: {
                '-12': 'A', '-11': 'B', '-10': 'C', '-9': 'D', '-8': 'E',
                '-7': 'F', '-6': 'G', '-5': 'H', '-4': 'I', '-3': 'J',
                '-2': 'K', '-1': 'L', '0': 'M', '1': 'N', '2': 'O',
                '3': 'P', '4': 'Q', '5': 'R', '6': 'S', '7': 'T',
                '8': 'U', '9': 'V', '10': 'W', '11': 'X', '12': 'Y'
            },

            // Update intervals (ms)
            intervals: {
                terminator: 60000,      // 1 minute
                iss: 5000,              // 5 seconds
                aircraft: 15000,        // 15 seconds (OpenSky rate limit)
                satellites: 30000,      // 30 seconds
                timezone: 1000          // 1 second
            },

            // Map settings
            map: {
                center: [20, 0],
                zoom: 2,
                minZoom: 1,
                maxZoom: 18
            },

            // Storage keys
            storage: {
                openweatherKey: 'geochron_openweather_key',
                proxyUrl: 'geochron_proxy_url',
                refreshInterval: 'geochron_refresh_interval',
                tleCache: 'geochron_tle_cache',
                settings: 'geochron_settings',
                openskyUsername: 'geochron_opensky_username',
                openskyPassword: 'geochron_opensky_password',
                userSatellites: 'geochron_user_satellites'
            },

            // Default colors for user satellites (cycle through these)
            satelliteColors: [
                '#ff6b6b', '#4ecdc4', '#ffe66d', '#95e1d3', '#f38181',
                '#aa96da', '#fcbad3', '#a8d8ea', '#ffb347', '#87ceeb'
            ]
        };

        /* ==========================================================================
           State
           ========================================================================== */
        const state = {
            map: null,
            layers: {
                terminator: null,
                sun: null,
                analemma: null,
                timezones: null,
                timezoneLabels: null,
                iss: null,
                issOrbit: null,
                satellites: null,
                aircraft: null,
                userSatellites: null,
                weather: {
                    radar: null,
                    clouds: null,
                    precipitation: null,
                    temp: null,
                    wind: null,
                    pressure: null
                }
            },
            markers: {
                sun: null,
                iss: null,
                aircraft: [],
                satellites: []
            },
            intervals: {
                terminator: null,
                iss: null,
                aircraft: null,
                satellites: null,
                timezone: null,
                analemma: null,
                userSatellites: null
            },
            data: {
                tle: null,
                aircraft: [],
                satelliteTrails: new Map(), // Map of satellite name -> array of [lat, lng] positions
                userSatelliteTrails: new Map(), // Map of user satellite id -> array of [lat, lng] positions
                timezones: null,          // GeoJSON timezone data
                timezoneOffsets: new Map(), // Map of tzid -> { offset, isFractional, centroid }
                userSatellites: [],       // Array of user satellite objects
                importPreview: []         // Temporary array for import preview
            },
            settings: {
                openweatherKey: '',
                proxyUrl: '',
                refreshInterval: 60,
                openskyUsername: '',
                openskyPassword: ''
            }
        };

        /* ==========================================================================
           Initialization
           ========================================================================== */
        document.addEventListener('DOMContentLoaded', init);

        async function init() {
            loadSettings();
            loadUserSatellites();
            initMap();
            initLayerToggles();
            initTLEImportHandlers();

            // Initialize default layers
            await initTerminator();
            initSunPosition();

            // Load timezone polygons (async) and initialize bar
            await initTimezonePolygons();
            initTimezoneBar();

            // Initialize user satellites layer and render list
            initUserSatellitesLayer();
            renderUserSatelliteList();

            // Hide loading overlay
            setTimeout(() => {
                document.getElementById('loadingOverlay').classList.add('hidden');
            }, 500);

            updateStatus('Ready', 'success');
        }

        /* ==========================================================================
           Settings Management
           ========================================================================== */
        function loadSettings() {
            state.settings.openweatherKey = localStorage.getItem(CONFIG.storage.openweatherKey) || '';
            state.settings.proxyUrl = localStorage.getItem(CONFIG.storage.proxyUrl) || CONFIG.defaultProxy;
            state.settings.refreshInterval = parseInt(localStorage.getItem(CONFIG.storage.refreshInterval)) || 60;
            state.settings.openskyUsername = localStorage.getItem(CONFIG.storage.openskyUsername) || '';
            state.settings.openskyPassword = localStorage.getItem(CONFIG.storage.openskyPassword) || '';

            // Update config intervals based on settings
            CONFIG.intervals.aircraft = state.settings.refreshInterval * 1000;
        }

        function saveSettings() {
            const openweatherKey = document.getElementById('apiKeyOpenWeather').value.trim();
            const proxyUrl = document.getElementById('proxyUrl').value.trim() || CONFIG.defaultProxy;
            const refreshInterval = parseInt(document.getElementById('refreshInterval').value) || 60;
            const openskyUsername = document.getElementById('openskyUsername').value.trim();
            const openskyPassword = document.getElementById('openskyPassword').value;

            localStorage.setItem(CONFIG.storage.openweatherKey, openweatherKey);
            localStorage.setItem(CONFIG.storage.proxyUrl, proxyUrl);
            localStorage.setItem(CONFIG.storage.refreshInterval, refreshInterval.toString());
            localStorage.setItem(CONFIG.storage.openskyUsername, openskyUsername);
            localStorage.setItem(CONFIG.storage.openskyPassword, openskyPassword);

            state.settings.openweatherKey = openweatherKey;
            state.settings.proxyUrl = proxyUrl;
            state.settings.refreshInterval = refreshInterval;
            state.settings.openskyUsername = openskyUsername;
            state.settings.openskyPassword = openskyPassword;
            CONFIG.intervals.aircraft = refreshInterval * 1000;

            // Update weather layer availability
            updateWeatherLayerStatus();

            closeSettings();
            updateStatus('Settings saved', 'success');
        }

        function openSettings() {
            document.getElementById('apiKeyOpenWeather').value = state.settings.openweatherKey;
            document.getElementById('proxyUrl').value = state.settings.proxyUrl;
            document.getElementById('refreshInterval').value = state.settings.refreshInterval;
            document.getElementById('openskyUsername').value = state.settings.openskyUsername;
            document.getElementById('openskyPassword').value = state.settings.openskyPassword;
            document.getElementById('settingsModal').classList.add('active');
        }

        function closeSettings() {
            document.getElementById('settingsModal').classList.remove('active');
        }

        function updateWeatherLayerStatus() {
            const hasKey = !!state.settings.openweatherKey;
            const weatherToggles = ['toggle-clouds', 'toggle-precipitation', 'toggle-temp', 'toggle-wind', 'toggle-pressure'];

            weatherToggles.forEach(id => {
                const toggle = document.getElementById(id);
                if (toggle) {
                    if (hasKey) {
                        toggle.classList.remove('disabled');
                        toggle.title = '';
                    } else {
                        toggle.classList.add('disabled');
                        toggle.title = 'API key required - click Settings';
                    }
                }
            });
        }

        /* ==========================================================================
           Map Initialization
           ========================================================================== */
        function initMap() {
            state.map = L.map('map', {
                center: CONFIG.map.center,
                zoom: CONFIG.map.zoom,
                minZoom: CONFIG.map.minZoom,
                maxZoom: CONFIG.map.maxZoom,
                worldCopyJump: true,
                zoomControl: true
            });

            // Dark tile layer (CartoDB Dark Matter)
            L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors &copy; <a href="https://carto.com/attributions">CARTO</a>',
                subdomains: 'abcd',
                maxZoom: 19
            }).addTo(state.map);

            // Move zoom control to bottom left
            state.map.zoomControl.setPosition('bottomleft');
        }

        /* ==========================================================================
           Timezone Bar
           ========================================================================== */
        function initTimezoneBar() {
            updateTimezoneBar();
            state.intervals.timezone = setInterval(updateTimezoneBar, CONFIG.intervals.timezone);
        }

        function updateTimezoneBar() {
            const bar = document.getElementById('timezoneBar');
            const now = new Date();
            const utcHour = now.getUTCHours();
            const utcMin = now.getUTCMinutes();

            // Get visible timezones based on map viewport
            const visibleOffsets = getVisibleTimezoneOffsets();

            if (visibleOffsets.length === 0) {
                // Fallback to all timezones if none detected
                for (let offset = -12; offset <= 12; offset++) {
                    visibleOffsets.push({ offset, isFractional: false });
                }
            }

            // Sort by offset
            visibleOffsets.sort((a, b) => a.offset - b.offset);

            // Remove duplicates
            const uniqueOffsets = [];
            const seen = new Set();
            visibleOffsets.forEach(v => {
                const key = v.offset.toString();
                if (!seen.has(key)) {
                    seen.add(key);
                    uniqueOffsets.push(v);
                }
            });

            // Generate HTML
            let html = '';
            uniqueOffsets.forEach(({ offset, isFractional }) => {
                const letter = getTimezoneLabel(offset);
                const offsetText = formatOffset(offset);

                // Calculate local time
                const totalMinutes = utcHour * 60 + utcMin + offset * 60;
                const localHour = Math.floor(((totalMinutes % 1440) + 1440) % 1440 / 60);
                const localMin = Math.round(((totalMinutes % 60) + 60) % 60);
                const time = `${localHour.toString().padStart(2, '0')}:${localMin.toString().padStart(2, '0')}`;

                const fractionalClass = isFractional ? 'fractional' : '';

                html += `
                    <div class="tz-label ${fractionalClass}">
                        <span class="tz-letter">${letter}</span>
                        <span class="tz-offset-text">UTC${offsetText}</span>
                        <span class="tz-time">${time}</span>
                    </div>
                `;
            });

            bar.innerHTML = html;
        }

        // Get timezone offsets visible in the current map viewport
        // Uses longitude-based calculation for reliability
        function getVisibleTimezoneOffsets() {
            if (!state.map) {
                // Return all standard offsets as fallback
                const fallback = [];
                for (let offset = -12; offset <= 12; offset++) {
                    fallback.push({ offset, isFractional: false });
                }
                return fallback;
            }

            const bounds = state.map.getBounds();
            let west = bounds.getWest();
            let east = bounds.getEast();

            // Handle world wrap (when viewing across the antimeridian)
            if (east < west) {
                east += 360;
            }

            // Calculate timezone offsets from longitude (15 degrees per hour)
            const minOffset = Math.max(-12, Math.floor(west / 15));
            const maxOffset = Math.min(14, Math.ceil(east / 15));

            const visibleOffsets = [];

            // Add integer offsets
            for (let offset = minOffset; offset <= maxOffset; offset++) {
                // Normalize offset to -12 to +14 range
                let normalizedOffset = offset;
                if (normalizedOffset > 14) normalizedOffset -= 24;
                if (normalizedOffset < -12) normalizedOffset += 24;

                visibleOffsets.push({ offset: normalizedOffset, isFractional: false });
            }

            // Check for fractional timezones in visible area from loaded data
            if (state.data.timezoneOffsets && state.data.timezoneOffsets.size > 0) {
                state.data.timezoneOffsets.forEach((info, tzid) => {
                    if (info.isFractional && info.bounds && bounds.intersects(info.bounds)) {
                        visibleOffsets.push({
                            offset: info.offset,
                            isFractional: true
                        });
                    }
                });
            }

            return visibleOffsets;
        }

        /* ==========================================================================
           Day/Night Terminator
           ========================================================================== */
        async function initTerminator() {
            state.layers.terminator = L.terminator({
                resolution: 2,
                fillColor: '#000',
                fillOpacity: 0.4,
                stroke: true,
                color: '#ff6b6b',
                weight: 1
            }).addTo(state.map);

            // Update terminator position periodically
            state.intervals.terminator = setInterval(() => {
                if (state.layers.terminator) {
                    state.layers.terminator.setTime();
                }
            }, CONFIG.intervals.terminator);
        }

        /* ==========================================================================
           Sun Position
           ========================================================================== */
        function initSunPosition() {
            updateSunPosition();

            // Update with terminator
            setInterval(updateSunPosition, CONFIG.intervals.terminator);
        }

        function updateSunPosition() {
            const sunPos = getSunPosition(new Date());

            if (state.markers.sun) {
                state.markers.sun.setLatLng([sunPos.lat, sunPos.lng]);
            } else {
                state.markers.sun = L.marker([sunPos.lat, sunPos.lng], {
                    icon: L.divIcon({
                        className: 'sun-marker',
                        html: '‚òÄÔ∏è',
                        iconSize: [24, 24],
                        iconAnchor: [12, 12]
                    })
                }).addTo(state.map);

                state.markers.sun.bindPopup(`
                    <div class="popup-title">‚òÄÔ∏è Sun (Subsolar Point)</div>
                    <div class="popup-row">
                        <span class="popup-label">Latitude</span>
                        <span>${sunPos.lat.toFixed(2)}¬∞</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Longitude</span>
                        <span>${sunPos.lng.toFixed(2)}¬∞</span>
                    </div>
                `);
            }

            // Update status
            document.getElementById('sunInfo').textContent =
                `Sun: ${sunPos.lat.toFixed(1)}¬∞, ${sunPos.lng.toFixed(1)}¬∞`;
        }

        function getSunPosition(date) {
            // Calculate subsolar point (where sun is directly overhead)
            const JD = getJulianDate(date);
            const D = JD - 2451545.0; // Days since J2000.0

            // Mean longitude of the Sun
            const g = (357.529 + 0.98560028 * D) * Math.PI / 180;
            const q = 280.459 + 0.98564736 * D;
            const L = (q + 1.915 * Math.sin(g) + 0.020 * Math.sin(2 * g)) * Math.PI / 180;

            // Obliquity of the ecliptic
            const e = (23.439 - 0.00000036 * D) * Math.PI / 180;

            // Right ascension and declination
            const sinL = Math.sin(L);
            const cosL = Math.cos(L);
            const sinE = Math.sin(e);
            const cosE = Math.cos(e);

            const RA = Math.atan2(cosE * sinL, cosL);
            const dec = Math.asin(sinE * sinL);

            // Greenwich Mean Sidereal Time
            const GMST = (18.697374558 + 24.06570982441908 * D) % 24;
            const GMSTrad = GMST * 15 * Math.PI / 180;

            // Subsolar longitude
            let lng = (RA - GMSTrad) * 180 / Math.PI;
            while (lng > 180) lng -= 360;
            while (lng < -180) lng += 360;

            return {
                lat: dec * 180 / Math.PI,
                lng: lng
            };
        }

        function getJulianDate(date) {
            return date.getTime() / 86400000 + 2440587.5;
        }

        /* ==========================================================================
           Analemma (Seasonal Sun Path)
           ========================================================================== */
        function initAnalemma() {
            updateAnalemma();

            // Update analemma periodically using user's refresh interval
            state.intervals.analemma = setInterval(updateAnalemma, state.settings.refreshInterval * 1000);
        }

        function updateAnalemma() {
            // Remove existing analemma layer if present
            if (state.layers.analemma) {
                state.map.removeLayer(state.layers.analemma);
            }

            state.layers.analemma = L.layerGroup().addTo(state.map);

            // Calculate analemma points - sun position at current UTC time for each day of year
            const now = new Date();
            const points = [];
            const year = now.getFullYear();

            // Use UTC time to avoid DST shifts affecting the analemma
            // Using local time would cause ~15¬∞ eastward shift during DST months
            const utcHours = now.getUTCHours();
            const utcMinutes = now.getUTCMinutes();
            const utcSeconds = now.getUTCSeconds();

            // Calculate for each day of the year
            for (let dayOfYear = 0; dayOfYear < 365; dayOfYear++) {
                // Create date for this day of year at current UTC time
                const date = new Date(Date.UTC(year, 0, 1 + dayOfYear,
                    utcHours, utcMinutes, utcSeconds));

                const sunPos = getSunPosition(date);
                points.push([sunPos.lat, sunPos.lng]);
            }

            // Close the loop
            points.push(points[0]);

            // Split polyline at antimeridian crossings to avoid wrapping artifacts
            const segments = [];
            let currentSegment = [points[0]];

            for (let i = 1; i < points.length; i++) {
                const prevLng = points[i - 1][1];
                const currLng = points[i][1];

                // Detect antimeridian crossing (large longitude jump > 180 degrees)
                if (Math.abs(currLng - prevLng) > 180) {
                    // End current segment and start a new one
                    if (currentSegment.length > 1) {
                        segments.push(currentSegment);
                    }
                    currentSegment = [points[i]];
                } else {
                    currentSegment.push(points[i]);
                }
            }

            // Add the last segment
            if (currentSegment.length > 1) {
                segments.push(currentSegment);
            }

            // Draw each segment as a separate polyline
            segments.forEach(segment => {
                const analemmaLine = L.polyline(segment, {
                    color: '#ffd700',
                    weight: 2,
                    opacity: 0.7,
                    dashArray: '5, 5',
                    interactive: false
                });
                state.layers.analemma.addLayer(analemmaLine);
            });

            // Add month markers on the analemma
            const monthNames = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
                               'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];

            for (let month = 0; month < 12; month++) {
                // Get position for the 15th of each month (using UTC to match analemma points)
                const date = new Date(Date.UTC(year, month, 15,
                    utcHours, utcMinutes, utcSeconds));
                const sunPos = getSunPosition(date);

                const monthMarker = L.circleMarker([sunPos.lat, sunPos.lng], {
                    radius: 4,
                    fillColor: '#ffd700',
                    fillOpacity: 0.9,
                    color: '#fff',
                    weight: 1
                });

                monthMarker.bindTooltip(monthNames[month], {
                    permanent: false,
                    direction: 'top',
                    className: 'analemma-tooltip'
                });

                state.layers.analemma.addLayer(monthMarker);
            }
        }

        function stopAnalemma() {
            if (state.intervals.analemma) {
                clearInterval(state.intervals.analemma);
                state.intervals.analemma = null;
            }
            if (state.layers.analemma) {
                state.map.removeLayer(state.layers.analemma);
                state.layers.analemma = null;
            }
        }

        /* ==========================================================================
           Timezone Polygons
           ========================================================================== */

        // Known timezone offsets for IANA timezone names
        // This maps common timezones to their standard UTC offset (ignoring DST)
        const TIMEZONE_OFFSETS = {
            // UTC-12 to UTC-1
            'Etc/GMT+12': -12, 'Pacific/Wake': -12,
            'Etc/GMT+11': -11, 'Pacific/Midway': -11, 'Pacific/Niue': -11, 'Pacific/Pago_Pago': -11,
            'Etc/GMT+10': -10, 'Pacific/Honolulu': -10, 'Pacific/Rarotonga': -10, 'Pacific/Tahiti': -10, 'America/Adak': -10,
            'Pacific/Marquesas': -9.5,
            'Etc/GMT+9': -9, 'America/Anchorage': -9, 'Pacific/Gambier': -9, 'America/Juneau': -9, 'America/Metlakatla': -9, 'America/Nome': -9, 'America/Sitka': -9, 'America/Yakutat': -9,
            'Etc/GMT+8': -8, 'America/Los_Angeles': -8, 'America/Tijuana': -8, 'America/Vancouver': -8, 'Pacific/Pitcairn': -8,
            'Etc/GMT+7': -7, 'America/Denver': -7, 'America/Phoenix': -7, 'America/Edmonton': -7, 'America/Hermosillo': -7, 'America/Mazatlan': -7, 'America/Chihuahua': -7, 'America/Ojinaga': -7,
            'Etc/GMT+6': -6, 'America/Chicago': -6, 'America/Mexico_City': -6, 'America/Winnipeg': -6, 'America/Costa_Rica': -6, 'America/Guatemala': -6, 'America/El_Salvador': -6, 'America/Tegucigalpa': -6, 'America/Managua': -6, 'America/Regina': -6,
            'Etc/GMT+5': -5, 'America/New_York': -5, 'America/Toronto': -5, 'America/Bogota': -5, 'America/Lima': -5, 'America/Panama': -5, 'America/Havana': -5, 'America/Jamaica': -5, 'America/Guayaquil': -5, 'America/Cancun': -5,
            'Etc/GMT+4': -4, 'America/Halifax': -4, 'America/Caracas': -4, 'America/La_Paz': -4, 'America/Santiago': -4, 'America/Santo_Domingo': -4, 'America/Puerto_Rico': -4, 'America/Barbados': -4, 'America/Manaus': -4, 'America/Martinique': -4, 'Atlantic/Bermuda': -4,
            'America/St_Johns': -3.5,
            'Etc/GMT+3': -3, 'America/Sao_Paulo': -3, 'America/Buenos_Aires': -3, 'America/Argentina/Buenos_Aires': -3, 'America/Montevideo': -3, 'America/Cayenne': -3, 'America/Paramaribo': -3, 'Atlantic/Stanley': -3, 'America/Godthab': -3, 'America/Nuuk': -3, 'America/Miquelon': -3,
            'Etc/GMT+2': -2, 'Atlantic/South_Georgia': -2, 'America/Noronha': -2,
            'Etc/GMT+1': -1, 'Atlantic/Azores': -1, 'Atlantic/Cape_Verde': -1,
            // UTC
            'Etc/GMT': 0, 'Etc/UTC': 0, 'UTC': 0, 'Europe/London': 0, 'Europe/Dublin': 0, 'Europe/Lisbon': 0, 'Atlantic/Reykjavik': 0, 'Africa/Casablanca': 0, 'Africa/Monrovia': 0, 'Africa/Accra': 0, 'Africa/Abidjan': 0, 'Africa/Dakar': 0,
            // UTC+1 to UTC+12
            'Etc/GMT-1': 1, 'Europe/Paris': 1, 'Europe/Berlin': 1, 'Europe/Rome': 1, 'Europe/Madrid': 1, 'Europe/Amsterdam': 1, 'Europe/Brussels': 1, 'Europe/Vienna': 1, 'Europe/Stockholm': 1, 'Europe/Oslo': 1, 'Europe/Copenhagen': 1, 'Europe/Warsaw': 1, 'Europe/Prague': 1, 'Europe/Budapest': 1, 'Europe/Belgrade': 1, 'Europe/Zurich': 1, 'Africa/Lagos': 1, 'Africa/Algiers': 1, 'Africa/Tunis': 1,
            'Etc/GMT-2': 2, 'Europe/Athens': 2, 'Europe/Helsinki': 2, 'Europe/Kiev': 2, 'Europe/Kyiv': 2, 'Europe/Bucharest': 2, 'Europe/Sofia': 2, 'Europe/Istanbul': 2, 'Africa/Cairo': 2, 'Africa/Johannesburg': 2, 'Africa/Harare': 2, 'Asia/Jerusalem': 2, 'Asia/Beirut': 2, 'Asia/Amman': 2, 'Asia/Damascus': 2,
            'Etc/GMT-3': 3, 'Europe/Moscow': 3, 'Europe/Minsk': 3, 'Asia/Baghdad': 3, 'Asia/Kuwait': 3, 'Asia/Riyadh': 3, 'Africa/Nairobi': 3, 'Africa/Addis_Ababa': 3, 'Asia/Qatar': 3, 'Asia/Bahrain': 3, 'Indian/Antananarivo': 3,
            'Asia/Tehran': 3.5, 'Iran': 3.5,
            'Etc/GMT-4': 4, 'Asia/Dubai': 4, 'Asia/Muscat': 4, 'Asia/Baku': 4, 'Asia/Tbilisi': 4, 'Asia/Yerevan': 4, 'Indian/Mauritius': 4, 'Indian/Reunion': 4, 'Europe/Samara': 4,
            'Asia/Kabul': 4.5, 'Afghanistan': 4.5,
            'Etc/GMT-5': 5, 'Asia/Karachi': 5, 'Asia/Tashkent': 5, 'Asia/Yekaterinburg': 5, 'Asia/Ashgabat': 5, 'Asia/Dushanbe': 5, 'Indian/Maldives': 5,
            'Asia/Kolkata': 5.5, 'Asia/Calcutta': 5.5, 'Asia/Colombo': 5.5, 'India': 5.5,
            'Asia/Kathmandu': 5.75, 'Asia/Katmandu': 5.75, 'Nepal': 5.75,
            'Etc/GMT-6': 6, 'Asia/Dhaka': 6, 'Asia/Almaty': 6, 'Asia/Bishkek': 6, 'Asia/Omsk': 6, 'Indian/Chagos': 6,
            'Asia/Yangon': 6.5, 'Asia/Rangoon': 6.5, 'Indian/Cocos': 6.5, 'Myanmar': 6.5,
            'Etc/GMT-7': 7, 'Asia/Bangkok': 7, 'Asia/Jakarta': 7, 'Asia/Ho_Chi_Minh': 7, 'Asia/Saigon': 7, 'Asia/Phnom_Penh': 7, 'Asia/Vientiane': 7, 'Asia/Novosibirsk': 7, 'Asia/Krasnoyarsk': 7,
            'Etc/GMT-8': 8, 'Asia/Shanghai': 8, 'Asia/Hong_Kong': 8, 'Asia/Singapore': 8, 'Asia/Taipei': 8, 'Asia/Kuala_Lumpur': 8, 'Asia/Manila': 8, 'Asia/Makassar': 8, 'Asia/Irkutsk': 8, 'Australia/Perth': 8, 'Asia/Brunei': 8,
            'Australia/Eucla': 8.75,
            'Etc/GMT-9': 9, 'Asia/Tokyo': 9, 'Asia/Seoul': 9, 'Asia/Pyongyang': 9, 'Asia/Yakutsk': 9, 'Asia/Chita': 9, 'Pacific/Palau': 9, 'Asia/Jayapura': 9, 'Asia/Dili': 9,
            'Australia/Darwin': 9.5, 'Australia/Adelaide': 9.5,
            'Etc/GMT-10': 10, 'Australia/Sydney': 10, 'Australia/Melbourne': 10, 'Australia/Brisbane': 10, 'Australia/Hobart': 10, 'Pacific/Guam': 10, 'Pacific/Port_Moresby': 10, 'Asia/Vladivostok': 10,
            'Australia/Lord_Howe': 10.5,
            'Etc/GMT-11': 11, 'Pacific/Noumea': 11, 'Pacific/Guadalcanal': 11, 'Asia/Magadan': 11, 'Asia/Sakhalin': 11, 'Pacific/Pohnpei': 11, 'Pacific/Kosrae': 11,
            'Pacific/Norfolk': 11.5,
            'Etc/GMT-12': 12, 'Pacific/Auckland': 12, 'Pacific/Fiji': 12, 'Asia/Kamchatka': 12, 'Pacific/Majuro': 12, 'Pacific/Tarawa': 12, 'Pacific/Kwajalein': 12, 'Pacific/Funafuti': 12, 'Pacific/Nauru': 12, 'Pacific/Wake': 12, 'Pacific/Wallis': 12,
            'Pacific/Chatham': 12.75,
            'Etc/GMT-13': 13, 'Pacific/Tongatapu': 13, 'Pacific/Enderbury': 13, 'Pacific/Fakaofo': 13, 'Pacific/Apia': 13,
            'Etc/GMT-14': 14, 'Pacific/Kiritimati': 14
        };

        // Get UTC offset for a timezone ID
        function getTimezoneOffset(tzid) {
            if (!tzid) return 0;

            // Check direct mapping
            if (TIMEZONE_OFFSETS[tzid] !== undefined) {
                return TIMEZONE_OFFSETS[tzid];
            }

            // Try to extract from Etc/GMT format
            const etcMatch = tzid.match(/^Etc\/GMT([+-]?\d+)$/);
            if (etcMatch) {
                // Etc/GMT uses inverted sign convention
                return -parseInt(etcMatch[1]);
            }

            // Default to 0 for unknown timezones
            console.warn(`Unknown timezone: ${tzid}`);
            return 0;
        }

        // Check if an offset is fractional (not a whole hour)
        function isFractionalOffset(offset) {
            return offset % 1 !== 0;
        }

        // Format offset for display
        function formatOffset(offset) {
            const sign = offset >= 0 ? '+' : '';
            if (Number.isInteger(offset)) {
                return `${sign}${offset}`;
            }
            const hours = Math.floor(Math.abs(offset));
            const minutes = Math.round((Math.abs(offset) % 1) * 60);
            const absSign = offset >= 0 ? '+' : '-';
            return `${absSign}${hours}:${minutes.toString().padStart(2, '0')}`;
        }

        // Get letter for integer offset, or formatted offset for fractional
        function getTimezoneLabel(offset) {
            const intOffset = Math.round(offset);
            if (isFractionalOffset(offset)) {
                return formatOffset(offset);
            }
            return CONFIG.timezoneLetters[intOffset.toString()] || formatOffset(offset);
        }

        // Calculate polygon centroid for label placement
        function getPolygonCentroid(coordinates) {
            let totalLat = 0, totalLng = 0, count = 0;

            function processRing(ring) {
                ring.forEach(coord => {
                    totalLng += coord[0];
                    totalLat += coord[1];
                    count++;
                });
            }

            if (coordinates[0] && Array.isArray(coordinates[0][0])) {
                // MultiPolygon or Polygon with holes
                coordinates.forEach(poly => {
                    if (Array.isArray(poly[0][0])) {
                        poly.forEach(ring => processRing(ring));
                    } else {
                        processRing(poly);
                    }
                });
            } else {
                processRing(coordinates);
            }

            return count > 0 ? [totalLat / count, totalLng / count] : [0, 0];
        }

        // Initialize timezone polygons
        async function initTimezonePolygons() {
            updateStatus('Loading timezone data...', 'loading');

            try {
                const response = await fetch(CONFIG.apis.timezones);
                const topoData = await response.json();

                // Convert TopoJSON to GeoJSON
                const objectName = Object.keys(topoData.objects)[0];
                const geoData = topojson.feature(topoData, topoData.objects[objectName]);
                state.data.timezones = geoData;

                // Create layer groups
                state.layers.timezones = L.layerGroup().addTo(state.map);
                state.layers.timezoneLabels = L.layerGroup().addTo(state.map);

                // Process each timezone feature
                const fractionalZones = [];

                geoData.features.forEach(feature => {
                    const props = feature.properties;

                    // Handle both IANA names (tzid) and Natural Earth format (zone as numeric offset)
                    let tzid, offset;

                    if (props.tzid || props.TZID) {
                        // IANA timezone name format
                        tzid = props.tzid || props.TZID;
                        offset = getTimezoneOffset(tzid);
                    } else if (props.zone !== undefined) {
                        // Natural Earth format: zone is numeric UTC offset
                        offset = parseFloat(props.zone);
                        tzid = props.tz_name1st || props.name || `UTC${formatOffset(offset)}`;
                    } else if (props.name) {
                        tzid = props.name;
                        offset = getTimezoneOffset(tzid);
                    } else {
                        tzid = 'Unknown';
                        offset = 0;
                    }

                    const centroid = getPolygonCentroid(feature.geometry.coordinates);

                    // Store timezone info (use unique key to avoid duplicates)
                    const key = `${tzid}_${offset}`;
                    state.data.timezoneOffsets.set(key, {
                        offset,
                        isFractional: isFractionalOffset(offset),
                        centroid,
                        bounds: L.geoJSON(feature).getBounds()
                    });

                    // Create polygon with thin grey border
                    const polygon = L.geoJSON(feature, {
                        style: {
                            color: 'rgba(128, 128, 128, 0.4)',
                            weight: 1,
                            fillColor: 'transparent',
                            fillOpacity: 0,
                            interactive: true
                        },
                        onEachFeature: (feat, layer) => {
                            // Hover tooltip
                            layer.on('mouseover', (e) => {
                                layer.setStyle({
                                    color: 'rgba(128, 128, 128, 0.8)',
                                    weight: 2
                                });
                                showTimezoneTooltip(e, tzid, offset);
                            });
                            layer.on('mouseout', () => {
                                layer.setStyle({
                                    color: 'rgba(128, 128, 128, 0.4)',
                                    weight: 1
                                });
                                hideTimezoneTooltip();
                            });
                            layer.on('mousemove', (e) => {
                                moveTimezoneTooltip(e);
                            });
                        }
                    });

                    state.layers.timezones.addLayer(polygon);

                    // Track fractional zones for labels
                    if (isFractionalOffset(offset)) {
                        fractionalZones.push({ tzid, offset, centroid });
                    }
                });

                // Add labels for fractional timezone offsets
                addFractionalTimezoneLabels(fractionalZones);

                // Set up viewport change listeners for header bar
                state.map.on('moveend', updateTimezoneBar);
                state.map.on('zoomend', updateTimezoneBar);

                updateStatus('Timezones loaded', 'success');
            } catch (error) {
                console.error('Failed to load timezone data:', error);
                updateStatus('Timezone load failed, using fallback', 'error');
                // Fallback to simple lines
                initTimezoneLinesFallback();
            }
        }

        // Fallback to simple timezone lines if GeoJSON fails to load
        function initTimezoneLinesFallback() {
            state.layers.timezones = L.layerGroup().addTo(state.map);

            for (let lng = -180; lng <= 180; lng += 15) {
                const line = L.polyline([[-90, lng], [90, lng]], {
                    color: 'rgba(128, 128, 128, 0.4)',
                    weight: 1,
                    dashArray: '4, 4',
                    interactive: false
                });
                state.layers.timezones.addLayer(line);
            }

            // Still set up viewport listeners for header bar
            state.map.on('moveend', updateTimezoneBar);
            state.map.on('zoomend', updateTimezoneBar);
        }

        // Add map labels for fractional timezones
        function addFractionalTimezoneLabels(zones) {
            // Group by offset to avoid duplicate labels
            const offsetGroups = new Map();
            zones.forEach(z => {
                const key = z.offset.toString();
                if (!offsetGroups.has(key)) {
                    offsetGroups.set(key, []);
                }
                offsetGroups.get(key).push(z);
            });

            offsetGroups.forEach((group, offsetKey) => {
                const offset = parseFloat(offsetKey);
                // Use the centroid of the largest zone (by count of zones with this offset)
                const primaryZone = group[0];

                const label = L.marker(primaryZone.centroid, {
                    icon: L.divIcon({
                        className: 'timezone-offset-label fractional',
                        html: `UTC${formatOffset(offset)}`,
                        iconSize: [60, 18],
                        iconAnchor: [30, 9]
                    }),
                    interactive: false
                });

                state.layers.timezoneLabels.addLayer(label);
            });
        }

        // Timezone hover tooltip functions
        function showTimezoneTooltip(e, tzid, offset) {
            let tooltip = document.getElementById('timezoneTooltip');
            if (!tooltip) {
                tooltip = document.createElement('div');
                tooltip.id = 'timezoneTooltip';
                tooltip.className = 'timezone-tooltip';
                document.body.appendChild(tooltip);
            }

            const now = new Date();
            const utcHour = now.getUTCHours();
            const utcMin = now.getUTCMinutes();
            const localHour = (utcHour + Math.floor(offset) + 24) % 24;
            const localMin = (utcMin + Math.round((offset % 1) * 60) + 60) % 60;
            const time = `${localHour.toString().padStart(2, '0')}:${localMin.toString().padStart(2, '0')}`;

            const letter = getTimezoneLabel(offset);
            const letterDisplay = isFractionalOffset(offset) ? '' : `<span style="color: var(--accent); font-weight: bold;">${letter}</span> ¬∑ `;

            tooltip.innerHTML = `
                <div class="tz-name">${tzid}</div>
                <div class="tz-offset">${letterDisplay}UTC${formatOffset(offset)} ¬∑ ${time}</div>
            `;
            tooltip.style.display = 'block';
            tooltip.style.left = (e.originalEvent.pageX + 15) + 'px';
            tooltip.style.top = (e.originalEvent.pageY + 15) + 'px';
        }

        function moveTimezoneTooltip(e) {
            const tooltip = document.getElementById('timezoneTooltip');
            if (tooltip) {
                tooltip.style.left = (e.originalEvent.pageX + 15) + 'px';
                tooltip.style.top = (e.originalEvent.pageY + 15) + 'px';
            }
        }

        function hideTimezoneTooltip() {
            const tooltip = document.getElementById('timezoneTooltip');
            if (tooltip) {
                tooltip.style.display = 'none';
            }
        }

        /* ==========================================================================
           ISS Tracking
           ========================================================================== */
        async function initISS() {
            await updateISSPosition();
            state.intervals.iss = setInterval(updateISSPosition, CONFIG.intervals.iss);
            document.getElementById('issStatus').style.display = 'flex';
        }

        async function stopISS() {
            if (state.intervals.iss) {
                clearInterval(state.intervals.iss);
                state.intervals.iss = null;
            }
            if (state.markers.iss) {
                state.map.removeLayer(state.markers.iss);
                state.markers.iss = null;
            }
            if (state.layers.issOrbit) {
                state.map.removeLayer(state.layers.issOrbit);
                state.layers.issOrbit = null;
            }
            document.getElementById('issStatus').style.display = 'none';
        }

        async function updateISSPosition() {
            try {
                // Use wheretheiss.at API (better CORS support)
                const response = await fetch(CONFIG.apis.issAlt);
                const data = await response.json();

                const lat = data.latitude;
                const lng = data.longitude;
                const alt = data.altitude;
                const velocity = data.velocity;

                if (state.markers.iss) {
                    state.markers.iss.setLatLng([lat, lng]);
                } else {
                    state.markers.iss = L.marker([lat, lng], {
                        icon: L.divIcon({
                            className: 'iss-marker',
                            html: 'üõ∏',
                            iconSize: [20, 20],
                            iconAnchor: [10, 10]
                        })
                    }).addTo(state.map);
                }

                state.markers.iss.bindPopup(`
                    <div class="popup-title">üõ∏ International Space Station</div>
                    <div class="popup-row">
                        <span class="popup-label">Latitude</span>
                        <span>${lat.toFixed(4)}¬∞</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Longitude</span>
                        <span>${lng.toFixed(4)}¬∞</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Altitude</span>
                        <span>${alt.toFixed(1)} km</span>
                    </div>
                    <div class="popup-row">
                        <span class="popup-label">Velocity</span>
                        <span>${velocity.toFixed(1)} km/h</span>
                    </div>
                `);

                document.getElementById('issInfo').textContent =
                    `${lat.toFixed(1)}¬∞, ${lng.toFixed(1)}¬∞ @ ${alt.toFixed(0)}km`;

            } catch (error) {
                console.error('ISS fetch error:', error);
                document.getElementById('issInfo').textContent = 'Error';
            }
        }

        /* ==========================================================================
           Satellite Tracking
           ========================================================================== */
        async function initSatellites() {
            updateStatus('Loading satellites...', 'loading');

            try {
                // Fetch TLE data from CelesTrak (active satellites)
                const response = await fetch(
                    `${CONFIG.apis.celestrak}?GROUP=active&FORMAT=tle`
                );
                const tleText = await response.text();
                state.data.tle = parseTLE(tleText);

                // Limit to first 200 satellites for performance
                const satellites = state.data.tle.slice(0, 200);

                state.layers.satellites = L.layerGroup().addTo(state.map);

                updateSatellitePositions(satellites);
                state.intervals.satellites = setInterval(
                    () => updateSatellitePositions(satellites),
                    CONFIG.intervals.satellites
                );

                updateStatus(`${satellites.length} satellites loaded`, 'success');
            } catch (error) {
                console.error('Satellite fetch error:', error);
                updateStatus('Failed to load satellites', 'error');
            }
        }

        async function stopSatellites() {
            if (state.intervals.satellites) {
                clearInterval(state.intervals.satellites);
                state.intervals.satellites = null;
            }
            if (state.layers.satellites) {
                state.map.removeLayer(state.layers.satellites);
                state.layers.satellites = null;
            }
            state.markers.satellites = [];
            state.data.satelliteTrails.clear(); // Clear trail history
        }

        function parseTLE(tleText) {
            const lines = tleText.trim().split('\n');
            const satellites = [];

            for (let i = 0; i < lines.length - 2; i += 3) {
                const name = lines[i].trim();
                const line1 = lines[i + 1];
                const line2 = lines[i + 2];

                if (line1 && line2 && line1.startsWith('1 ') && line2.startsWith('2 ')) {
                    satellites.push({ name, line1, line2 });
                }
            }

            return satellites;
        }

        function updateSatellitePositions(satellites) {
            if (!state.layers.satellites) return;

            state.layers.satellites.clearLayers();
            const now = new Date();

            // Maximum number of trail points to keep (about 10% of a 90-minute orbit)
            // At 30-second intervals, 18 points = 9 minutes
            const MAX_TRAIL_POINTS = 18;

            satellites.forEach(sat => {
                try {
                    const satrec = satellite.twoline2satrec(sat.line1, sat.line2);
                    const positionAndVelocity = satellite.propagate(satrec, now);

                    if (positionAndVelocity.position) {
                        const gmst = satellite.gstime(now);
                        const position = satellite.eciToGeodetic(positionAndVelocity.position, gmst);

                        const lat = satellite.degreesLat(position.latitude);
                        const lng = satellite.degreesLong(position.longitude);
                        const alt = position.height;

                        // Update trail history
                        if (!state.data.satelliteTrails.has(sat.name)) {
                            state.data.satelliteTrails.set(sat.name, []);
                        }
                        const trail = state.data.satelliteTrails.get(sat.name);
                        trail.push([lat, lng]);

                        // Keep only the last MAX_TRAIL_POINTS positions
                        if (trail.length > MAX_TRAIL_POINTS) {
                            trail.shift();
                        }

                        // Draw trail if we have at least 2 points
                        if (trail.length > 1) {
                            const trailLine = L.polyline(trail, {
                                color: '#4fc3f7',
                                weight: 1.5,
                                opacity: 0.4,
                                smoothFactor: 1
                            });
                            state.layers.satellites.addLayer(trailLine);
                        }

                        // Draw satellite marker on top of trail
                        const marker = L.marker([lat, lng], {
                            icon: L.divIcon({
                                className: 'satellite-marker',
                                html: '‚Ä¢',
                                iconSize: [14, 14],
                                iconAnchor: [7, 7]
                            })
                        });

                        marker.bindPopup(`
                            <div class="popup-title">üì° ${sat.name}</div>
                            <div class="popup-row">
                                <span class="popup-label">Latitude</span>
                                <span>${lat.toFixed(2)}¬∞</span>
                            </div>
                            <div class="popup-row">
                                <span class="popup-label">Longitude</span>
                                <span>${lng.toFixed(2)}¬∞</span>
                            </div>
                            <div class="popup-row">
                                <span class="popup-label">Altitude</span>
                                <span>${alt.toFixed(0)} km</span>
                            </div>
                        `);

                        state.layers.satellites.addLayer(marker);
                    }
                } catch (e) {
                    // Skip satellites with invalid TLE
                }
            });
        }

        /* ==========================================================================
           User Satellite Management
           ========================================================================== */

        // Enhanced TLE parser supporting 2LE, 3LE, comments, and edge cases
        function parseEnhancedTLE(tleText) {
            // Normalize line endings and split
            const lines = tleText
                .replace(/\r\n/g, '\n')
                .replace(/\r/g, '\n')
                .split('\n')
                .map(line => line.trimEnd())  // Keep leading spaces but trim trailing
                .filter(line => line.length > 0 && !line.startsWith('#')); // Remove empty lines and comments

            const satellites = [];
            const errors = [];
            let i = 0;

            while (i < lines.length) {
                const currentLine = lines[i];

                // Check if this looks like TLE Line 1
                if (currentLine.match(/^1\s+\d/)) {
                    // 2LE format - no name line
                    const line1 = currentLine;
                    const line2 = lines[i + 1];

                    if (line2 && line2.match(/^2\s+\d/)) {
                        // Extract NORAD ID from line 1 for name
                        const noradId = line1.substring(2, 7).trim();
                        const result = validateAndParseTLE(`NORAD ${noradId}`, line1, line2);
                        if (result.valid) {
                            satellites.push(result.satellite);
                        } else {
                            errors.push(result.error);
                        }
                        i += 2;
                    } else {
                        errors.push(`Line ${i + 1}: Expected Line 2 after Line 1`);
                        i++;
                    }
                } else if (!currentLine.match(/^[12]\s+\d/)) {
                    // This should be a name line (3LE format)
                    const name = currentLine.trim();
                    const line1 = lines[i + 1];
                    const line2 = lines[i + 2];

                    if (line1 && line2 && line1.match(/^1\s+\d/) && line2.match(/^2\s+\d/)) {
                        const result = validateAndParseTLE(name, line1, line2);
                        if (result.valid) {
                            satellites.push(result.satellite);
                        } else {
                            errors.push(result.error);
                        }
                        i += 3;
                    } else {
                        // Not a valid TLE block, skip this line
                        errors.push(`Line ${i + 1}: "${name.substring(0, 20)}..." - Missing or invalid TLE lines`);
                        i++;
                    }
                } else {
                    // Unexpected line, skip
                    i++;
                }
            }

            return { satellites, errors };
        }

        function validateAndParseTLE(name, line1, line2) {
            // Validate line lengths (should be 69 characters)
            if (line1.length < 68 || line2.length < 68) {
                return {
                    valid: false,
                    error: `${name}: TLE lines too short (Line1: ${line1.length}, Line2: ${line2.length})`
                };
            }

            // Validate checksums
            const checksum1 = calculateTLEChecksum(line1.substring(0, 68));
            const checksum2 = calculateTLEChecksum(line2.substring(0, 68));
            const expected1 = parseInt(line1[68]) || 0;
            const expected2 = parseInt(line2[68]) || 0;

            const checksumValid = (checksum1 === expected1) && (checksum2 === expected2);

            // Extract NORAD catalog ID (supports Alpha-5 format)
            const noradId = line1.substring(2, 7).trim();

            // Parse epoch from line 1
            const epochYear = parseInt(line1.substring(18, 20));
            const epochDay = parseFloat(line1.substring(20, 32));

            // Convert 2-digit year to 4-digit (assumes 57-99 = 1957-1999, 00-56 = 2000-2056)
            const fullYear = epochYear >= 57 ? 1900 + epochYear : 2000 + epochYear;

            // Calculate epoch date
            const epochDate = new Date(Date.UTC(fullYear, 0, 1));
            epochDate.setUTCDate(epochDay);

            // Calculate age in days
            const ageMs = Date.now() - epochDate.getTime();
            const ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));

            return {
                valid: true,
                checksumValid,
                satellite: {
                    name: name,
                    noradId: noradId,
                    line1: line1.substring(0, 69),
                    line2: line2.substring(0, 69),
                    epoch: epochDate.toISOString(),
                    ageDays: ageDays
                }
            };
        }

        function calculateTLEChecksum(line) {
            let sum = 0;
            for (let i = 0; i < 68; i++) {
                const char = line[i];
                if (char >= '0' && char <= '9') {
                    sum += parseInt(char);
                } else if (char === '-') {
                    sum += 1;
                }
                // Letters, spaces, periods, plus signs are ignored
            }
            return sum % 10;
        }

        // Load user satellites from localStorage
        function loadUserSatellites() {
            try {
                const stored = localStorage.getItem(CONFIG.storage.userSatellites);
                if (stored) {
                    state.data.userSatellites = JSON.parse(stored);

                    // Recalculate age for each satellite
                    state.data.userSatellites.forEach(sat => {
                        const epochDate = new Date(sat.epoch);
                        const ageMs = Date.now() - epochDate.getTime();
                        sat.ageDays = Math.floor(ageMs / (1000 * 60 * 60 * 24));
                    });
                }
            } catch (e) {
                console.error('Failed to load user satellites:', e);
                state.data.userSatellites = [];
            }
        }

        // Save user satellites to localStorage
        function saveUserSatellites() {
            try {
                localStorage.setItem(
                    CONFIG.storage.userSatellites,
                    JSON.stringify(state.data.userSatellites)
                );
            } catch (e) {
                console.error('Failed to save user satellites:', e);
                if (e.name === 'QuotaExceededError') {
                    alert('Local storage is full. Please delete some satellites to save more.');
                }
            }
        }

        // Initialize user satellites layer
        function initUserSatellitesLayer() {
            if (!state.layers.userSatellites) {
                state.layers.userSatellites = L.layerGroup().addTo(state.map);
            }

            // Start update interval if we have visible satellites
            const hasVisible = state.data.userSatellites.some(s => s.visible);
            if (hasVisible && !state.intervals.userSatellites) {
                updateUserSatellitePositions();
                state.intervals.userSatellites = setInterval(
                    updateUserSatellitePositions,
                    5000 // Update every 5 seconds for better tracking
                );
            }
        }

        // Update positions for all visible user satellites
        function updateUserSatellitePositions() {
            if (!state.layers.userSatellites) return;

            state.layers.userSatellites.clearLayers();
            const now = new Date();
            const MAX_TRAIL_POINTS = 24; // More trail points for user satellites

            state.data.userSatellites.forEach(sat => {
                if (!sat.visible) return;

                try {
                    const satrec = satellite.twoline2satrec(sat.line1, sat.line2);
                    const positionAndVelocity = satellite.propagate(satrec, now);

                    if (positionAndVelocity.position) {
                        const gmst = satellite.gstime(now);
                        const position = satellite.eciToGeodetic(positionAndVelocity.position, gmst);

                        const lat = satellite.degreesLat(position.latitude);
                        const lng = satellite.degreesLong(position.longitude);
                        const alt = position.height;

                        // Update trail history
                        if (!state.data.userSatelliteTrails.has(sat.id)) {
                            state.data.userSatelliteTrails.set(sat.id, []);
                        }
                        const trail = state.data.userSatelliteTrails.get(sat.id);
                        trail.push([lat, lng]);

                        if (trail.length > MAX_TRAIL_POINTS) {
                            trail.shift();
                        }

                        // Draw trail with satellite's color
                        if (trail.length > 1) {
                            const trailLine = L.polyline(trail, {
                                color: sat.color,
                                weight: 2.5,
                                opacity: 0.6,
                                smoothFactor: 1
                            });
                            state.layers.userSatellites.addLayer(trailLine);
                        }

                        // Draw satellite marker
                        const marker = L.marker([lat, lng], {
                            icon: L.divIcon({
                                className: 'user-satellite-marker',
                                html: `<span style="color: ${sat.color}">${sat.icon || 'üõ∞Ô∏è'}</span>`,
                                iconSize: [20, 20],
                                iconAnchor: [10, 10]
                            }),
                            zIndexOffset: 1000 // Ensure user satellites are on top
                        });

                        // Staleness warning for popup
                        let stalenessNote = '';
                        if (sat.ageDays > 14) {
                            stalenessNote = `<div class="popup-row" style="color: var(--accent);">
                                <span class="popup-label">‚ö†Ô∏è Warning</span>
                                <span>TLE is ${sat.ageDays} days old</span>
                            </div>`;
                        } else if (sat.ageDays > 7) {
                            stalenessNote = `<div class="popup-row" style="color: var(--warning);">
                                <span class="popup-label">‚ö†Ô∏è Note</span>
                                <span>TLE is ${sat.ageDays} days old</span>
                            </div>`;
                        }

                        marker.bindPopup(`
                            <div class="popup-title">${sat.icon || 'üõ∞Ô∏è'} ${sat.name}</div>
                            <div class="popup-row">
                                <span class="popup-label">NORAD ID</span>
                                <span>${sat.noradId}</span>
                            </div>
                            <div class="popup-row">
                                <span class="popup-label">Latitude</span>
                                <span>${lat.toFixed(4)}¬∞</span>
                            </div>
                            <div class="popup-row">
                                <span class="popup-label">Longitude</span>
                                <span>${lng.toFixed(4)}¬∞</span>
                            </div>
                            <div class="popup-row">
                                <span class="popup-label">Altitude</span>
                                <span>${alt.toFixed(1)} km</span>
                            </div>
                            ${stalenessNote}
                        `);

                        state.layers.userSatellites.addLayer(marker);

                        // Add label if enabled
                        if (sat.showLabel !== false) {
                            const label = L.marker([lat, lng], {
                                icon: L.divIcon({
                                    className: 'user-satellite-label',
                                    html: sat.name,
                                    iconSize: [100, 16],
                                    iconAnchor: [-12, 8]
                                }),
                                interactive: false
                            });
                            state.layers.userSatellites.addLayer(label);
                        }
                    }
                } catch (e) {
                    console.error(`Failed to update position for ${sat.name}:`, e);
                }
            });
        }

        // Render the user satellite list in the layer panel
        function renderUserSatelliteList() {
            const container = document.getElementById('userSatList');
            const clearBtn = document.getElementById('clearAllSatsBtn');
            const count = state.data.userSatellites.length;

            // Show/hide Clear All button
            clearBtn.style.display = count > 0 ? 'flex' : 'none';

            if (count === 0) {
                container.innerHTML = `
                    <div class="user-sat-empty">
                        No satellites added yet.<br>
                        Import a TLE to track custom satellites.
                    </div>
                `;
                return;
            }

            // For large lists, show summary instead of all items
            const MAX_DISPLAY = 50;
            const displaySats = state.data.userSatellites.slice(0, MAX_DISPLAY);
            const hiddenCount = count - MAX_DISPLAY;

            let html = displaySats.map(sat => {
                let metaClass = '';
                let metaText = `${sat.ageDays} day${sat.ageDays !== 1 ? 's' : ''} old`;

                if (sat.ageDays > 14) {
                    metaClass = 'very-stale';
                    metaText = `‚ö†Ô∏è ${metaText} (stale)`;
                } else if (sat.ageDays > 7) {
                    metaClass = 'stale';
                    metaText = `‚ö†Ô∏è ${metaText}`;
                }

                return `
                    <div class="user-sat-item" data-id="${sat.id}">
                        <div class="user-sat-color" style="background: ${sat.color};"
                             onclick="changeUserSatColor('${sat.id}')" title="Change color"></div>
                        <div class="user-sat-info">
                            <div class="user-sat-name">${sat.icon || 'üõ∞Ô∏è'} ${sat.name}</div>
                            <div class="user-sat-meta ${metaClass}">${metaText}</div>
                        </div>
                        <div class="user-sat-toggle ${sat.visible ? 'active' : ''}"
                             onclick="toggleUserSatVisibility('${sat.id}')" title="Toggle visibility"></div>
                        <div class="user-sat-actions">
                            <button class="user-sat-btn" onclick="editUserSat('${sat.id}')" title="Edit">‚úèÔ∏è</button>
                            <button class="user-sat-btn delete" onclick="deleteUserSat('${sat.id}')" title="Delete">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');

            if (hiddenCount > 0) {
                html += `
                    <div class="user-sat-empty" style="padding: 8px;">
                        ... and ${hiddenCount.toLocaleString()} more satellites<br>
                        <small>Use "Clear All" to remove all at once</small>
                    </div>
                `;
            }

            container.innerHTML = html;
        }

        // Toggle visibility of a user satellite
        function toggleUserSatVisibility(id) {
            const sat = state.data.userSatellites.find(s => s.id === id);
            if (sat) {
                sat.visible = !sat.visible;
                saveUserSatellites();
                renderUserSatelliteList();

                // Clear trail when hiding
                if (!sat.visible) {
                    state.data.userSatelliteTrails.delete(id);
                }

                // Update positions and manage interval
                updateUserSatellitePositions();

                const hasVisible = state.data.userSatellites.some(s => s.visible);
                if (hasVisible && !state.intervals.userSatellites) {
                    state.intervals.userSatellites = setInterval(
                        updateUserSatellitePositions,
                        5000
                    );
                } else if (!hasVisible && state.intervals.userSatellites) {
                    clearInterval(state.intervals.userSatellites);
                    state.intervals.userSatellites = null;
                }
            }
        }

        // Change color of a user satellite
        function changeUserSatColor(id) {
            const sat = state.data.userSatellites.find(s => s.id === id);
            if (!sat) return;

            // Create a temporary color input
            const input = document.createElement('input');
            input.type = 'color';
            input.value = sat.color;
            input.style.position = 'absolute';
            input.style.visibility = 'hidden';

            input.addEventListener('change', () => {
                sat.color = input.value;
                saveUserSatellites();
                renderUserSatelliteList();
                updateUserSatellitePositions();
                document.body.removeChild(input);
            });

            input.addEventListener('blur', () => {
                setTimeout(() => {
                    if (document.body.contains(input)) {
                        document.body.removeChild(input);
                    }
                }, 100);
            });

            document.body.appendChild(input);
            input.click();
        }

        // Edit user satellite (name, icon)
        function editUserSat(id) {
            const sat = state.data.userSatellites.find(s => s.id === id);
            if (!sat) return;

            const newName = prompt('Enter satellite name:', sat.name);
            if (newName && newName.trim()) {
                sat.name = newName.trim();
                saveUserSatellites();
                renderUserSatelliteList();
                updateUserSatellitePositions();
            }
        }

        // Delete a user satellite
        function deleteUserSat(id) {
            const sat = state.data.userSatellites.find(s => s.id === id);
            if (!sat) return;

            if (confirm(`Delete "${sat.name}" from your satellites?`)) {
                state.data.userSatellites = state.data.userSatellites.filter(s => s.id !== id);
                state.data.userSatelliteTrails.delete(id);
                saveUserSatellites();
                renderUserSatelliteList();
                updateUserSatellitePositions();

                // Stop interval if no visible satellites
                const hasVisible = state.data.userSatellites.some(s => s.visible);
                if (!hasVisible && state.intervals.userSatellites) {
                    clearInterval(state.intervals.userSatellites);
                    state.intervals.userSatellites = null;
                }
            }
        }

        // Clear all user satellites
        function clearAllUserSatellites() {
            const count = state.data.userSatellites.length;
            if (count === 0) return;

            if (confirm(`Delete all ${count} satellites from your list?`)) {
                state.data.userSatellites = [];
                state.data.userSatelliteTrails.clear();
                saveUserSatellites();
                renderUserSatelliteList();
                updateUserSatellitePositions();

                // Stop the update interval
                if (state.intervals.userSatellites) {
                    clearInterval(state.intervals.userSatellites);
                    state.intervals.userSatellites = null;
                }

                updateStatus('All satellites cleared', 'success');
            }
        }

        // Generate unique ID for satellites
        function generateSatId() {
            return 'sat_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        // Get next color from palette
        function getNextSatColor() {
            const usedColors = state.data.userSatellites.map(s => s.color);
            const availableColors = CONFIG.satelliteColors.filter(c => !usedColors.includes(c));
            if (availableColors.length > 0) {
                return availableColors[0];
            }
            // If all colors used, cycle through
            return CONFIG.satelliteColors[state.data.userSatellites.length % CONFIG.satelliteColors.length];
        }

        /* ==========================================================================
           TLE Import Modal
           ========================================================================== */

        function openTLEImport() {
            document.getElementById('tleImportModal').classList.add('active');
            document.getElementById('tleTextarea').value = '';
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('importBtn').disabled = true;
            state.data.importPreview = [];
            switchImportTab('paste');
        }

        function closeTLEImport() {
            document.getElementById('tleImportModal').classList.remove('active');
            state.data.importPreview = [];
        }

        function switchImportTab(tab) {
            // Update tab buttons
            document.querySelectorAll('.import-tab').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tab === tab);
            });

            // Update panels
            document.getElementById('importPanelPaste').classList.toggle('active', tab === 'paste');
            document.getElementById('importPanelFile').classList.toggle('active', tab === 'file');
        }

        function initTLEImportHandlers() {
            // Textarea input handler with debounce
            let debounceTimer;
            document.getElementById('tleTextarea').addEventListener('input', (e) => {
                clearTimeout(debounceTimer);
                debounceTimer = setTimeout(() => {
                    previewTLEInput(e.target.value);
                }, 300);
            });

            // File drop zone handlers
            const dropZone = document.getElementById('fileDropZone');

            dropZone.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropZone.classList.add('dragover');
            });

            dropZone.addEventListener('dragleave', () => {
                dropZone.classList.remove('dragover');
            });

            dropZone.addEventListener('drop', (e) => {
                e.preventDefault();
                dropZone.classList.remove('dragover');
                const file = e.dataTransfer.files[0];
                if (file) {
                    readTLEFile(file);
                }
            });

            // Keyboard shortcut to close modal
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeTLEImport();
                }
            });
        }

        function handleFileSelect(event) {
            const file = event.target.files[0];
            if (file) {
                readTLEFile(file);
            }
        }

        function readTLEFile(file) {
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                previewTLEInput(content);
            };
            reader.onerror = () => {
                alert('Failed to read file');
            };
            reader.readAsText(file);
        }

        function previewTLEInput(text) {
            const preview = document.getElementById('importPreview');
            const previewList = document.getElementById('previewList');
            const previewCount = document.getElementById('previewCount');
            const previewMessages = document.getElementById('previewMessages');
            const importBtn = document.getElementById('importBtn');

            if (!text.trim()) {
                preview.style.display = 'none';
                importBtn.disabled = true;
                state.data.importPreview = [];
                return;
            }

            const { satellites, errors } = parseEnhancedTLE(text);

            // Show preview
            preview.style.display = 'block';

            // Show errors/warnings
            let messagesHtml = '';
            if (errors.length > 0) {
                const displayErrors = errors.slice(0, 3);
                messagesHtml = `
                    <div class="preview-warning preview-error">
                        ‚ö†Ô∏è ${errors.length} parsing issue${errors.length > 1 ? 's' : ''}:
                        ${displayErrors.join('; ')}${errors.length > 3 ? '...' : ''}
                    </div>
                `;
            }

            // Check for stale TLEs
            const staleSats = satellites.filter(s => s.ageDays > 7);
            if (staleSats.length > 0) {
                messagesHtml += `
                    <div class="preview-warning">
                        ‚ö†Ô∏è ${staleSats.length} satellite${staleSats.length > 1 ? 's have' : ' has'}
                        TLE data older than 7 days - positions may be inaccurate
                    </div>
                `;
            }

            previewMessages.innerHTML = messagesHtml;

            // Check for duplicates
            const existingNoradIds = state.data.userSatellites.map(s => s.noradId);

            // Build preview list with selection and color
            state.data.importPreview = satellites.map((sat, index) => ({
                ...sat,
                selected: true,
                color: getNextColorForIndex(index),
                isDuplicate: existingNoradIds.includes(sat.noradId)
            }));

            previewCount.textContent = `${satellites.length} satellite${satellites.length !== 1 ? 's' : ''} found`;

            previewList.innerHTML = state.data.importPreview.map((sat, index) => `
                <div class="preview-item">
                    <input type="checkbox" class="preview-checkbox"
                           ${sat.selected ? 'checked' : ''}
                           onchange="togglePreviewSelection(${index})">
                    <div class="preview-info">
                        <div class="preview-name">
                            ${sat.name}
                            ${sat.isDuplicate ? '<span style="color: var(--warning);">(duplicate)</span>' : ''}
                        </div>
                        <div class="preview-meta">
                            NORAD: ${sat.noradId} ¬∑ ${sat.ageDays} day${sat.ageDays !== 1 ? 's' : ''} old
                        </div>
                    </div>
                    <input type="color" class="preview-color-picker"
                           value="${sat.color}"
                           onchange="updatePreviewColor(${index}, this.value)">
                </div>
            `).join('');

            // Enable/disable import button
            const selectedCount = state.data.importPreview.filter(s => s.selected).length;
            importBtn.disabled = selectedCount === 0;
            importBtn.textContent = `Import ${selectedCount > 0 ? selectedCount + ' ' : ''}Selected`;
        }

        function getNextColorForIndex(index) {
            const usedCount = state.data.userSatellites.length;
            return CONFIG.satelliteColors[(usedCount + index) % CONFIG.satelliteColors.length];
        }

        function togglePreviewSelection(index) {
            state.data.importPreview[index].selected = !state.data.importPreview[index].selected;
            const selectedCount = state.data.importPreview.filter(s => s.selected).length;
            const importBtn = document.getElementById('importBtn');
            importBtn.disabled = selectedCount === 0;
            importBtn.textContent = `Import ${selectedCount > 0 ? selectedCount + ' ' : ''}Selected`;
        }

        function updatePreviewColor(index, color) {
            state.data.importPreview[index].color = color;
        }

        function importSelectedSatellites() {
            const toImport = state.data.importPreview.filter(s => s.selected);

            if (toImport.length === 0) {
                alert('No satellites selected');
                return;
            }

            // Check for duplicates and ask about replacement
            const existingByNorad = new Map(
                state.data.userSatellites.map(s => [s.noradId, s])
            );

            let replacedCount = 0;

            toImport.forEach(sat => {
                const existing = existingByNorad.get(sat.noradId);

                if (existing) {
                    // Replace existing satellite's TLE data
                    existing.line1 = sat.line1;
                    existing.line2 = sat.line2;
                    existing.epoch = sat.epoch;
                    existing.ageDays = sat.ageDays;
                    // Keep existing name, color, visibility
                    replacedCount++;
                } else {
                    // Add new satellite
                    state.data.userSatellites.push({
                        id: generateSatId(),
                        name: sat.name,
                        noradId: sat.noradId,
                        line1: sat.line1,
                        line2: sat.line2,
                        epoch: sat.epoch,
                        ageDays: sat.ageDays,
                        color: sat.color,
                        icon: 'üõ∞Ô∏è',
                        visible: true,
                        showLabel: true,
                        addedAt: new Date().toISOString(),
                        source: 'manual'
                    });
                }
            });

            saveUserSatellites();
            renderUserSatelliteList();
            initUserSatellitesLayer(); // Ensure interval is running
            updateUserSatellitePositions();

            closeTLEImport();

            const newCount = toImport.length - replacedCount;
            let message = '';
            if (newCount > 0 && replacedCount > 0) {
                message = `Added ${newCount} new satellite${newCount !== 1 ? 's' : ''}, updated ${replacedCount}`;
            } else if (newCount > 0) {
                message = `Added ${newCount} satellite${newCount !== 1 ? 's' : ''}`;
            } else {
                message = `Updated ${replacedCount} satellite${replacedCount !== 1 ? 's' : ''}`;
            }
            updateStatus(message, 'success');
        }

        /* ==========================================================================
           Aircraft Tracking
           ========================================================================== */
        async function initAircraft() {
            document.getElementById('aircraftStatus').style.display = 'flex';
            state.layers.aircraft = L.layerGroup().addTo(state.map);

            await updateAircraftPositions();
            state.intervals.aircraft = setInterval(updateAircraftPositions, CONFIG.intervals.aircraft);
        }

        async function stopAircraft() {
            if (state.intervals.aircraft) {
                clearInterval(state.intervals.aircraft);
                state.intervals.aircraft = null;
            }
            if (state.layers.aircraft) {
                state.map.removeLayer(state.layers.aircraft);
                state.layers.aircraft = null;
            }
            document.getElementById('aircraftStatus').style.display = 'none';
        }

        async function updateAircraftPositions() {
            try {
                updateStatus('Fetching aircraft...', 'loading');

                // Get current map bounds to limit request
                const bounds = state.map.getBounds();
                const openskyUrl = `${CONFIG.apis.opensky}?lamin=${bounds.getSouth()}&lomin=${bounds.getWest()}&lamax=${bounds.getNorth()}&lomax=${bounds.getEast()}`;

                // Check if we have OpenSky credentials
                const hasAuth = state.settings.openskyUsername && state.settings.openskyPassword;

                // Build proxy URL with optional auth (OAuth2 client credentials)
                const proxyBase = state.settings.proxyUrl.replace(/\/+$/, ''); // Remove trailing slashes
                let proxyUrl = `${proxyBase}?url=${encodeURIComponent(openskyUrl)}`;
                
                if (hasAuth) {
                    proxyUrl += `&auth=${encodeURIComponent(btoa(state.settings.openskyUsername + ':' + state.settings.openskyPassword))}`;
                }

                console.log(`Fetching aircraft ${hasAuth ? 'with' : 'without'} auth...`);
                const response = await fetch(proxyUrl);

                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                }

                const data = await response.json();
                console.log('Aircraft fetch succeeded');

                if (!state.layers.aircraft) return;
                state.layers.aircraft.clearLayers();

                if (data.states) {
                    // Limit to 500 aircraft for performance
                    const aircraft = data.states.slice(0, 500);

                    aircraft.forEach(ac => {
                        const [
                            icao24, callsign, originCountry, timePosition, lastContact,
                            longitude, latitude, baroAltitude, onGround, velocity,
                            trueTrack, verticalRate, sensors, geoAltitude, squawk,
                            spi, positionSource
                        ] = ac;

                        if (latitude && longitude) {
                            // Adjust rotation: plane emoji points east by default, subtract 90¬∞ to make 0¬∞ = north
                            const rotation = trueTrack ? (trueTrack - 90) : 0;

                            const marker = L.marker([latitude, longitude], {
                                icon: L.divIcon({
                                    className: 'aircraft-marker',
                                    html: `<span style="transform: rotate(${rotation}deg); display: inline-block;">‚úà</span>`,
                                    iconSize: [14, 14],
                                    iconAnchor: [7, 7]
                                }),
                                rotationAngle: rotation
                            });

                            const alt = baroAltitude ? `${(baroAltitude * 3.28084).toFixed(0)} ft` : 'N/A';
                            const speed = velocity ? `${(velocity * 1.94384).toFixed(0)} kts` : 'N/A';

                            marker.bindPopup(`
                                <div class="popup-title">‚úàÔ∏è ${(callsign || 'Unknown').trim() || icao24}</div>
                                <div class="popup-row">
                                    <span class="popup-label">ICAO24</span>
                                    <span>${icao24}</span>
                                </div>
                                <div class="popup-row">
                                    <span class="popup-label">Country</span>
                                    <span>${originCountry}</span>
                                </div>
                                <div class="popup-row">
                                    <span class="popup-label">Altitude</span>
                                    <span>${alt}</span>
                                </div>
                                <div class="popup-row">
                                    <span class="popup-label">Speed</span>
                                    <span>${speed}</span>
                                </div>
                                <div class="popup-row">
                                    <span class="popup-label">Heading</span>
                                    <span>${trueTrack ? trueTrack.toFixed(0) + '¬∞' : 'N/A'}</span>
                                </div>
                            `);

                            state.layers.aircraft.addLayer(marker);
                        }
                    });

                    document.getElementById('aircraftInfo').textContent = `${aircraft.length} visible`;
                    updateStatus(`${aircraft.length} aircraft loaded`, 'success');
                }
            } catch (error) {
                console.error('Aircraft fetch error:', error);
                document.getElementById('aircraftInfo').textContent = 'Error';
                updateStatus('Aircraft fetch failed', 'error');
            }
        }

        /* ==========================================================================
           Weather Layers
           ========================================================================== */

        // RainViewer - Free radar layer (no API key required)
        async function initRadarLayer() {
            try {
                // Get the latest radar timestamp from RainViewer API
                const response = await fetch('https://api.rainviewer.com/public/weather-maps.json');
                const data = await response.json();

                if (data.radar && data.radar.past && data.radar.past.length > 0) {
                    // Get the most recent radar frame
                    const latestFrame = data.radar.past[data.radar.past.length - 1];
                    const radarPath = latestFrame.path;

                    state.layers.weather.radar = L.tileLayer(
                        `https://tilecache.rainviewer.com${radarPath}/256/{z}/{x}/{y}/2/1_1.png`,
                        {
                            opacity: 0.7,
                            attribution: '&copy; <a href="https://rainviewer.com">RainViewer</a>',
                            crossOrigin: 'anonymous'
                        }
                    ).addTo(state.map);

                    return true;
                }
                return false;
            } catch (error) {
                console.error('RainViewer init error:', error);
                return false;
            }
        }

        function stopRadarLayer() {
            if (state.layers.weather.radar) {
                state.map.removeLayer(state.layers.weather.radar);
                state.layers.weather.radar = null;
            }
        }

        // OpenWeatherMap layers (requires API key)
        function initWeatherLayer(layerType) {
            if (!state.settings.openweatherKey) {
                alert('Please add your OpenWeatherMap API key in Settings first.');
                return false;
            }

            const layerMap = {
                clouds: 'clouds_new',
                precipitation: 'precipitation_new',
                temp: 'temp_new',
                wind: 'wind_new',
                pressure: 'pressure_new'
            };

            const owmLayer = layerMap[layerType];
            if (!owmLayer) return false;

            state.layers.weather[layerType] = L.tileLayer(
                `${CONFIG.apis.openweather}/${owmLayer}/{z}/{x}/{y}.png?appid=${state.settings.openweatherKey}`,
                {
                    opacity: 0.6,
                    attribution: '&copy; <a href="https://openweathermap.org">OpenWeatherMap</a>',
                    crossOrigin: 'anonymous'
                }
            ).addTo(state.map);

            return true;
        }

        function stopWeatherLayer(layerType) {
            if (state.layers.weather[layerType]) {
                state.map.removeLayer(state.layers.weather[layerType]);
                state.layers.weather[layerType] = null;
            }
        }

        /* ==========================================================================
           Layer Toggle Management
           ========================================================================== */
        function initLayerToggles() {
            // Core layers
            document.getElementById('layer-terminator').addEventListener('change', (e) => {
                if (e.target.checked) {
                    state.layers.terminator.addTo(state.map);
                } else {
                    state.map.removeLayer(state.layers.terminator);
                }
            });

            document.getElementById('layer-sun').addEventListener('change', (e) => {
                if (e.target.checked && state.markers.sun) {
                    state.markers.sun.addTo(state.map);
                } else if (state.markers.sun) {
                    state.map.removeLayer(state.markers.sun);
                }
            });

            // Analemma
            document.getElementById('layer-analemma').addEventListener('change', (e) => {
                if (e.target.checked) {
                    initAnalemma();
                } else {
                    stopAnalemma();
                }
            });

            document.getElementById('layer-timezones').addEventListener('change', (e) => {
                if (e.target.checked) {
                    if (state.layers.timezones) state.layers.timezones.addTo(state.map);
                    if (state.layers.timezoneLabels) state.layers.timezoneLabels.addTo(state.map);
                } else {
                    if (state.layers.timezones) state.map.removeLayer(state.layers.timezones);
                    if (state.layers.timezoneLabels) state.map.removeLayer(state.layers.timezoneLabels);
                }
            });

            // ISS
            document.getElementById('layer-iss').addEventListener('change', (e) => {
                if (e.target.checked) {
                    initISS();
                } else {
                    stopISS();
                }
            });

            // Satellites
            document.getElementById('layer-satellites').addEventListener('change', (e) => {
                if (e.target.checked) {
                    initSatellites();
                } else {
                    stopSatellites();
                }
            });

            // RainViewer radar (free, no API key)
            document.getElementById('layer-radar').addEventListener('change', async (e) => {
                if (e.target.checked) {
                    const success = await initRadarLayer();
                    if (!success) {
                        e.target.checked = false;
                        alert('Failed to load radar data. Please try again.');
                    }
                } else {
                    stopRadarLayer();
                }
            });

            // OpenWeatherMap layers (requires API key)
            ['clouds', 'precipitation', 'temp', 'wind', 'pressure'].forEach(type => {
                document.getElementById(`layer-${type}`).addEventListener('change', (e) => {
                    if (e.target.checked) {
                        if (!initWeatherLayer(type)) {
                            e.target.checked = false;
                        }
                    } else {
                        stopWeatherLayer(type);
                    }
                });
            });

            // Aircraft
            document.getElementById('layer-aircraft').addEventListener('change', (e) => {
                if (e.target.checked) {
                    initAircraft();
                } else {
                    stopAircraft();
                }
            });

            // Update weather layer availability
            updateWeatherLayerStatus();
        }

        /* ==========================================================================
           UI Helpers
           ========================================================================== */
        function toggleControlPanel() {
            const panel = document.getElementById('controlPanel');
            const toggle = document.getElementById('panelToggle');
            panel.classList.toggle('collapsed');
            toggle.textContent = panel.classList.contains('collapsed') ? '+' : '‚àí';
        }

        function updateStatus(message, type = 'success') {
            const dot = document.getElementById('statusDot');
            const text = document.getElementById('statusText');

            dot.className = 'status-dot';
            if (type === 'loading') dot.classList.add('loading');
            if (type === 'error') dot.classList.add('error');

            text.textContent = message;
        }

        /* ==========================================================================
           Keyboard Shortcuts
           ========================================================================== */
        document.addEventListener('keydown', (e) => {
            // Escape closes modal
            if (e.key === 'Escape') {
                closeSettings();
            }

            // F for fullscreen
            if (e.key === 'f' && !e.ctrlKey && !e.metaKey && document.activeElement.tagName !== 'INPUT') {
                if (document.fullscreenElement) {
                    document.exitFullscreen();
                } else {
                    document.documentElement.requestFullscreen();
                }
            }
        });
    </script>
</body>
</html>
